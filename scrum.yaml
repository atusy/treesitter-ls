# AI-Agentic Scrum Dashboard
# Single source of truth for all Scrum artifacts
# Git tracks when changes were made - no timestamps needed
# Order is priority - higher items have higher priority
# Historical details: git log -- scrum.yaml

---
# ==============================================================================
# RULES (Condensed)
# ==============================================================================

rules:
  core:
    - "Single Source of Truth: This dashboard is the only place for Scrum artifacts"
    - "Git as History: Do not add timestamps. Use git log for history"
    - "Order is Priority: Items higher in lists have higher priority"
    - "1 Sprint = 1 PBI: Each Sprint delivers exactly one PBI"

  definition_of_ready:
    summary: "Ready = AI can complete it without asking humans"
    flow: "draft -> refining -> ready"

  tdd_workflow:
    cycle: "pending -> red (commit) -> green (commit) -> refactoring (commit) -> completed"
    discipline: "ONE commit per TDD phase. Never mix behavioral and structural changes"

  agent_responsibilities:
    product_owner: "Product Backlog, Product Goal, Sprint acceptance"
    scrum_master: "Sprint config, Impediments, Retrospective, Metrics"
    developer: "Subtask status, Progress, Notes, Impediments"

---
# ==============================================================================
# QUICK STATUS
# ==============================================================================

quick_status:
  current_sprint:
    number: 20
    pbi: PBI-027
    status: done
    goal: "Fix failing selection range test for markdown"
  impediments: 0

---
# ==============================================================================
# PRODUCT GOAL
# ==============================================================================

product_goal:
  statement: "Enable zero-configuration usage of treesitter-ls: users can start the LSP server and get syntax highlighting for any supported language without manual setup."
  mvp_status: COMPLETE
  mvp_definition: |
    Minimum Viable Zero-Config Experience:
    1. User starts treesitter-ls with no initialization options
    2. User opens a .lua file (or any supported language)
    3. treesitter-ls automatically:
       a. Detects the language from file extension (via LSP languageId)
       b. Installs the parser and queries if missing (autoInstall: true by default)
       c. Uses default searchPaths (~/.local/share/treesitter-ls/{parser,queries})
       d. Provides semantic highlighting
    4. Power users can still override with explicit configuration
  owner: "@scrum-team-product-owner"

---
# ==============================================================================
# PRODUCT BACKLOG (Active Items Only)
# ==============================================================================
# Completed PBIs: PBI-001 through PBI-010, PBI-013 through PBI-027
# Tidying PBIs: PBI-029 through PBI-033 (technical debt reduction)
# For details: git log -- scrum.yaml
#
product_backlog:
  # ============================================================================
  # ACTIVE PBIs
  # ============================================================================
  - id: PBI-028
    status: ready
    story:
      role: "user of treesitter-ls"
      capability: "get syntax highlighting without specifying searchPaths in config"
      benefit: "I can use zero-config mode as intended without manually configuring paths"
    acceptance_criteria:
      - criterion: "default_search_paths() returns base directory, not subdirectories"
        verification: |
          # Default should be ["/Users/.../treesitter-ls"], not [".../parser", ".../queries"]
          cargo test test_default_search_paths_format
      - criterion: "Highlighting works when searchPaths is not specified in init_options"
        verification: |
          # With searchPaths commented out in minimal_init.lua, opening a file should highlight
          nvim -es --headless -u scripts/minimal_init.lua -c "e tests/assets/example.lua" -c "sleep 2" -c "lua print(#vim.lsp.semantic_tokens.get(0, {}, {}) > 0 and 'OK' or 'FAIL')" -c "qa!"
      - criterion: "Documentation updated to clarify searchPaths format"
        verification: |
          grep -E "searchPaths.*base directory|searchPaths.*not.*subdirectories" docs/README.md
      - criterion: "Product goal MVP definition updated to reflect correct path format"
        verification: |
          grep -v "parser,queries" scrum.yaml | grep -E "default.*searchPaths"
    story_points: 2
    technical_notes: |
      Bug: default_search_paths() returns wrong path format

      Current behavior (BROKEN):
        default_search_paths() returns:
          [".../treesitter-ls/parser", ".../treesitter-ls/queries"]

        But resolve_library_path() expects base directories and appends "parser/" itself:
          PathBuf::from(path).join("parser").join(format!("{language}.so"))

        Result: Looks for ".../treesitter-ls/parser/parser/lua.so" → NOT FOUND

      Expected behavior:
        default_search_paths() should return:
          [".../treesitter-ls"]

        Then resolve_library_path() correctly finds:
          ".../treesitter-ls/parser/lua.so"

      Fix location: src/config.rs, default_search_paths() function

      Documentation to update:
        - docs/README.md: Clarify searchPaths format (base directories, not subdirs)
        - scrum.yaml: Fix product_goal.mvp_definition line 60

  # ============================================================================
  # TIDYING PBIs (Technical Debt Reduction)
  # ============================================================================
  - id: PBI-029
    status: draft
    story:
      role: "developer maintaining treesitter-ls"
      capability: "work with a codebase free of dead and deprecated code"
      benefit: "I can understand the codebase faster without being confused by unused code"
    acceptance_criteria:
      - criterion: "No #[allow(dead_code)] annotations in production code"
        verification: |
          ! grep -r "#\[allow(dead_code)\]" src/ --include="*.rs" | grep -v test
      - criterion: "No #[deprecated] functions in the codebase"
        verification: |
          ! grep -r "#\[deprecated" src/ --include="*.rs"
      - criterion: "No placeholder tests with assert!(true)"
        verification: |
          ! grep -r "assert!(true)" src/ --include="*.rs"
    story_points: 1
    technical_notes: |
      Quick Wins - Dead Code Removal (Tidy First candidates)

      1. src/language/failed_parsers.rs:
         - Remove is_parser_failed() marked #[allow(dead_code)]
         - Remove clear_failed_parser() marked #[allow(dead_code)]
         - These were for "later subtasks (ST-5)" that never materialized

      2. src/language/injection.rs:252:
         - Remove parse_offset_directive() marked #[deprecated]
         - Note says "returns incorrect offsets" - kept for testing
         - Update any tests that depend on it

      3. src/language/predicate_accessor.rs:
         - Remove or implement placeholder test: test_unified_predicate_operator()
         - Currently just assert!(true)

      Estimated time: 15-20 minutes total

  - id: PBI-030
    status: draft
    story:
      role: "developer maintaining treesitter-ls"
      capability: "use consistent lock handling patterns across the codebase"
      benefit: "I can trust that all locks are handled safely and code is DRY"
    acceptance_criteria:
      - criterion: "All lock() calls use LockResultExt trait methods"
        verification: |
          # No manual match on lock() result - use recover_poison_with_log() instead
          ! grep -A5 "\.lock()" src/lsp/lsp_impl.rs | grep "Err(poisoned)"
      - criterion: "LockResultExt is imported where locks are used"
        verification: |
          grep "use crate::error::LockResultExt" src/lsp/lsp_impl.rs
      - criterion: "All tests pass after refactoring"
        verification: |
          cargo test
    story_points: 1
    technical_notes: |
      Eliminate Lock Pattern Duplication (Tidy First)

      Current state: 4+ instances of manual poison recovery in lsp_impl.rs:
        match self.parser_pool.lock() {
            Ok(guard) => guard,
            Err(poisoned) => {
                log::warn!(target: "...", "Recovered from poisoned lock");
                poisoned.into_inner()
            }
        }

      The LockResultExt trait in error.rs already provides:
        - recover_poison() - silent recovery
        - recover_poison_with_log(target, message) - logged recovery

      Refactor to:
        self.parser_pool.lock().recover_poison_with_log(
            "treesitter_ls::lock_recovery",
            "Recovered from poisoned parser_pool lock"
        )

      Estimated time: 15 minutes

  - id: PBI-031
    status: draft
    story:
      role: "developer maintaining treesitter-ls"
      capability: "read dense functions with clear visual grouping"
      benefit: "I can quickly understand function flow by scanning logical chunks"
    acceptance_criteria:
      - criterion: "parse_document() has blank lines separating logical steps"
        verification: |
          # Manual review: lsp_impl.rs parse_document should have 4-5 logical chunks
          grep -A100 "fn parse_document" src/lsp/lsp_impl.rs | head -120
      - criterion: "handle_semantic_tokens_full() has blank lines separating phases"
        verification: |
          # Manual review: semantic.rs should chunk: setup, query, process, cache
          grep -A120 "fn handle_semantic_tokens_full" src/analysis/semantic.rs | head -140
      - criterion: "All tests pass (no behavioral change)"
        verification: |
          cargo test
    story_points: 1
    technical_notes: |
      Chunk Statements in Dense Functions (Tidy First)

      Add blank lines to group related statements in:

      1. src/lsp/lsp_impl.rs - parse_document():
         - Chunk: Get document and language
         - Chunk: Acquire parser from pool
         - Chunk: Parse with tree-sitter
         - Chunk: Update document store

      2. src/analysis/semantic.rs - handle_semantic_tokens_full():
         - Chunk: Setup and early returns
         - Chunk: Query execution
         - Chunk: Token processing
         - Chunk: Caching and return

      Structural change only - no behavioral modifications.
      Estimated time: 10 minutes per function

  - id: PBI-032
    status: draft
    story:
      role: "developer maintaining treesitter-ls"
      capability: "work with a smaller, more focused lsp_impl.rs"
      benefit: "I can navigate and modify LSP code without scrolling through 2400 lines"
    acceptance_criteria:
      - criterion: "lsp_impl.rs is under 1500 lines"
        verification: |
          [ $(wc -l < src/lsp/lsp_impl.rs) -lt 1500 ]
      - criterion: "Auto-install logic extracted to separate module"
        verification: |
          test -f src/lsp/auto_install.rs
      - criterion: "Settings loading extracted to settings module"
        verification: |
          grep -q "fn load_settings" src/lsp/settings.rs
      - criterion: "All tests pass"
        verification: |
          cargo test
    story_points: 3
    technical_notes: |
      Split God Object: lsp_impl.rs (Tidy Later - Substantial)

      Current: 2391 lines handling multiple concerns

      Extraction targets:
      1. Auto-install logic → src/lsp/auto_install.rs (~200 lines)
         - ensure_language_installed()
         - install_language_async()
         - handle_missing_parser()

      2. Settings loading → src/lsp/settings.rs (expand existing)
         - load_settings_from_init_options()
         - merge_with_toml_config()
         - validate_settings()

      3. Document parsing → src/lsp/parsing.rs (~150 lines)
         - parse_document()
         - incremental_parse()

      Keep in lsp_impl.rs:
      - LSP trait implementations
      - Request/notification routing
      - State coordination

      Estimated time: 2-3 hours

  - id: PBI-033
    status: draft
    story:
      role: "developer maintaining treesitter-ls"
      capability: "understand code action APIs without navigating 5 function variants"
      benefit: "I can extend code actions without confusion about which function to call"
    acceptance_criteria:
      - criterion: "Single entry point for code actions with options struct"
        verification: |
          grep -q "pub struct CodeActionOptions" src/analysis/refactor.rs
      - criterion: "No more than 2 public handle_code_actions functions"
        verification: |
          [ $(grep -c "pub fn handle_code_actions" src/analysis/refactor.rs) -le 2 ]
      - criterion: "All tests pass"
        verification: |
          cargo test
    story_points: 2
    technical_notes: |
      Consolidate Code Action Function Variants (Tidy Later)

      Current state (5 variants):
        pub fn handle_code_actions(...)
        pub fn handle_code_actions_with_injection_query(...)
        pub fn handle_code_actions_with_injection_and_coordinator(...)
        fn handle_code_actions_with_context(...)
        fn handle_nested_injection(...)

      Refactor to builder/options pattern:
        pub struct CodeActionOptions<'a> {
            document: &'a Document,
            range: Range,
            injection_query: Option<&'a Query>,
            coordinator: Option<&'a LanguageCoordinator>,
        }

        impl<'a> CodeActionOptions<'a> {
            pub fn new(document: &'a Document, range: Range) -> Self { ... }
            pub fn with_injection(self, query: &'a Query) -> Self { ... }
            pub fn with_coordinator(self, coord: &'a LanguageCoordinator) -> Self { ... }
        }

        pub fn handle_code_actions(options: CodeActionOptions) -> Vec<CodeAction>

      Estimated time: 30-45 minutes

  # ============================================================================
  # LOGGING PBIs (Observability Improvements)
  # ============================================================================
  - id: PBI-034
    status: draft
    story:
      role: "operator running treesitter-ls"
      capability: "see log messages via RUST_LOG environment variable"
      benefit: "I can diagnose issues when the LSP server misbehaves"
    acceptance_criteria:
      - criterion: "env_logger crate is added to Cargo.toml dependencies"
        verification: |
          grep -q 'env_logger' Cargo.toml
      - criterion: "env_logger::init() is called in run_lsp_server() before server starts"
        verification: |
          grep -q 'env_logger' src/bin/main.rs
      - criterion: "Running RUST_LOG=treesitter_ls=warn treesitter-ls outputs log messages"
        verification: |
          RUST_LOG=treesitter_ls=warn cargo run 2>&1 | head -1  # Manual test
      - criterion: "Log output goes to stderr (not stdout, which is used for LSP JSON-RPC)"
        verification: |
          grep -q 'Target::Stderr' src/bin/main.rs
    story_points: 2
    technical_notes: |
      Initialize Logging Backend (Foundation)

      The log crate is used throughout but no backend is initialized - all logs are no-ops.

      Implementation:
        use env_logger::Builder;
        use std::io::Write;

        Builder::from_default_env()
            .target(env_logger::Target::Stderr)  # CRITICAL: stdout is LSP JSON-RPC
            .init();

      MUST use stderr because stdout is the LSP protocol channel.

  - id: PBI-035
    status: draft
    story:
      role: "operator filtering logs"
      capability: "filter warnings by category using RUST_LOG targets"
      benefit: "I can see only relevant logs without noise from other categories"
    acceptance_criteria:
      - criterion: "src/error.rs:61 recover_poison() includes target: treesitter_ls::lock_recovery"
        verification: |
          grep -A5 'fn recover_poison\b' src/error.rs | grep 'target.*lock_recovery'
      - criterion: "src/language/injection.rs warnings use target: treesitter_ls::query"
        verification: |
          grep 'log::warn!' src/language/injection.rs | grep -c 'target.*treesitter_ls::query' | grep -q '2'
      - criterion: "All log::warn! calls have explicit targets"
        verification: |
          ! grep -r 'log::warn!' src/ --include='*.rs' | grep -v 'target:'
    story_points: 1
    technical_notes: |
      Standardize Log Targets

      Three log targets for different audiences:
        - treesitter_ls::lock_recovery  → Server operators (thread safety)
        - treesitter_ls::crash_recovery → Server operators (parser crashes)
        - treesitter_ls::query          → Query authors (malformed queries)

      Files to update:
        - src/error.rs:61 → add target: "treesitter_ls::lock_recovery"
        - src/language/injection.rs:88,138 → add target: "treesitter_ls::query"

      The injection.rs warnings are about malformed #offset! directives - user config
      issues, not server health. Separating them lets query authors filter independently.

  - id: PBI-036
    status: draft
    story:
      role: "developer debugging lock issues"
      capability: "see which operation triggered lock poisoning recovery"
      benefit: "I can identify which component experienced the lock poisoning"
    acceptance_criteria:
      - criterion: "recover_poison() function includes context in message"
        verification: |
          grep -A10 'fn recover_poison\b' src/error.rs | grep 'Recovered.*in'
      - criterion: "No context-less recover_poison variant exists"
        verification: |
          ! grep -A5 'fn recover_poison\b' src/error.rs | grep -q '"Recovered from poisoned lock"$'
    story_points: 2
    technical_notes: |
      Add Context to Recover Poison Warning

      Current state in error.rs:
        - recover_poison() at line 57-64: no target, no context
        - recover_poison_with_log() at line 67-79: has target and context

      Options:
        1. Remove recover_poison(), keep only recover_poison_with_log()
        2. Add context param to recover_poison()
        3. Rename recover_poison_with_log() to recover_poison() after removing old one

      Recommendation: Option 3 - consolidate to single function with context.

  - id: PBI-037
    status: draft
    story:
      role: "operator monitoring logs"
      capability: "see crash detection events at error level instead of warn"
      benefit: "I can configure alerts on the more severe error level for crashes"
    acceptance_criteria:
      - criterion: "src/language/failed_parsers.rs uses log::error! for crash detection"
        verification: |
          grep 'log::error!' src/language/failed_parsers.rs | grep 'crash_recovery'
      - criterion: "Target remains treesitter_ls::crash_recovery"
        verification: |
          grep 'crash_recovery' src/language/failed_parsers.rs
    story_points: 1
    technical_notes: |
      Use Error Level for Crash Detection

      Crash detection indicates a parser caused SIGABRT - genuinely an error condition.
      The warn level is for "recovered gracefully"; crash means "something bad happened".

      Change in src/language/failed_parsers.rs:68:
        - log::warn!(target: "treesitter_ls::crash_recovery", ...)
        + log::error!(target: "treesitter_ls::crash_recovery", ...)

  - id: PBI-038
    status: draft
    story:
      role: "operator configuring treesitter-ls"
      capability: "read documentation about available log targets"
      benefit: "I can configure RUST_LOG effectively without reading source code"
    acceptance_criteria:
      - criterion: "docs/README.md includes Logging section"
        verification: |
          grep -q '## Logging' docs/README.md
      - criterion: "Documents all three log targets with descriptions"
        verification: |
          grep -q 'lock_recovery' docs/README.md && grep -q 'crash_recovery' docs/README.md && grep -q 'treesitter_ls::query' docs/README.md
      - criterion: "Includes example RUST_LOG configurations"
        verification: |
          grep -q 'RUST_LOG=' docs/README.md
      - criterion: "Notes that logs go to stderr"
        verification: |
          grep -qi 'stderr' docs/README.md
    story_points: 2
    technical_notes: |
      Document Logging Targets

      Add to docs/README.md:

      ## Logging

      treesitter-ls uses Rust's standard logging with env_logger.
      Enable logging via RUST_LOG:

      | Target | Level | Description |
      |--------|-------|-------------|
      | treesitter_ls::lock_recovery | warn | Thread synchronization recovery |
      | treesitter_ls::crash_recovery | error | Parser crash detection |
      | treesitter_ls::query | warn | Query syntax/validation issues |

      Examples:
        RUST_LOG=treesitter_ls=debug treesitter-ls          # All logs
        RUST_LOG=treesitter_ls::crash_recovery=error ...    # Crashes only
        RUST_LOG=treesitter_ls::query=warn ...              # Query issues only

      Note: Logs are written to stderr. Stdout is reserved for LSP JSON-RPC.

  # ============================================================================
  # COMPLETED PBIs (details in git history)
  # ============================================================================
  - id: PBI-025
    status: done
  - id: PBI-026
    status: done
  - id: PBI-021
    status: done
  - id: PBI-022
    status: done
  - id: PBI-023
    status: done
  - id: PBI-024
    status: done
  - id: PBI-027
    status: done
  - id: PBI-015
    status: done
  - id: PBI-010
    status: done
  - id: PBI-016
    status: done
  - id: PBI-020
    status: done

---
# ==============================================================================
# DEFINITION OF READY
# ==============================================================================

definition_of_ready:
  criteria:
    - "AI can complete this story without human input"
    - "User story has role, capability, and benefit"
    - "At least 3 acceptance criteria with verification commands"
    - "Dependencies are resolved or not blocking"

---
# ==============================================================================
# DEFINITION OF DONE
# ==============================================================================

definition_of_done:
  checks:
    - name: "All unit tests pass"
      run: "make test"
    - name: "Code quality checks pass"
      run: "make check"
    - name: "E2E tests pass"
      run: "make test_nvim"

---
# ==============================================================================
# CURRENT SPRINT
# ==============================================================================

current_sprint:
  number: 20
  pbi: PBI-027
  status: done
  goal: "Fix failing selection range test for markdown"
  subtasks:
    - id: S20.1
      task: "Update test expectation to match actual markdown AST structure"
      status: completed

---
# ==============================================================================
# COMPLETED SPRINTS (Summary Only)
# ==============================================================================
# For detailed subtasks and commits: git log -- scrum.yaml

completed_sprints:
  - sprint: 20
    pbi: PBI-027
    outcome: "Fixed markdown selection range test expectation to match AST structure"
  - sprint: 19
    pbi: PBI-024
    outcome: "Added language uninstall command with confirmation prompt and --all flag"
  - sprint: 18
    pbi: PBI-023
    outcome: "Added language status command to show installed languages and missing components"
  - sprint: 17
    pbi: PBI-022
    outcome: "Added config init command to generate treesitter-ls.toml template"
  - sprint: 16
    pbi: PBI-021
    outcome: "Added Prerequisites section to docs/README.md with dependency requirements"
  - sprint: 15
    pbi: PBI-026
    outcome: "CLI migrated to hierarchical structure: treesitter-ls language {install,list}"
  - sprint: 14
    pbi: PBI-025
    outcome: "ADR documentation with template and ADR-0001 (hierarchical CLI subcommands)"
  - sprint: 13
    pbi: PBI-020
    outcome: "Query inheritance support via parse_inherits_directive() and resolve_query_with_inheritance()"
  - sprint: 12
    pbi: PBI-016
    outcome: "Parser crash resilience via state file detection and CLI recovery"
  - sprint: 11
    pbi: PBI-010
    outcome: "Cache parsers.lua locally with 1-hour TTL and --no-cache flag"
  - sprint: 10
    pbi: PBI-015
    outcome: "Fixed git checkout for tag revisions using FETCH_HEAD"
  - sprint: 9
    pbi: [PBI-017, PBI-018, PBI-019]
    outcome: "Zero-Config MVP complete - default searchPaths, autoInstall=true by default"
  - sprint: 8
    pbi: PBI-013
    outcome: "Auto-install for injected languages on file open"
  - sprint: 7
    pbi: PBI-008
    outcome: "Auto-install infrastructure (silent background install)"
  - sprint: 6
    pbi: PBI-009
    outcome: "Combined install command (parser + queries)"
  - sprint: 5
    pbi: PBI-006
    outcome: "Parser compilation via tree-sitter CLI"
  - sprint: 4
    pbi: PBI-005
    outcome: "Query downloading from nvim-treesitter"
  - sprint: 3
    pbi: PBI-004
    outcome: "CLI infrastructure with clap"
  - sprint: 2
    pbi: PBI-002
    outcome: "Unified semantic token handlers; fixed PBI-003"
  - sprint: 1
    pbi: PBI-001
    outcome: "Semantic tokens for injected languages"

---
# ==============================================================================
# IMPEDIMENTS
# ==============================================================================

impediments:
  active: []
  # Format: {id, description, impact, severity, status}

---
# ==============================================================================
# AGENTS
# ==============================================================================

agents:
  roles:
    product_owner: "@scrum-team-product-owner"
    scrum_master: "@scrum-team-scrum-master"
    developer: "@scrum-team-developer"
  events:
    planning: "@scrum-event-sprint-planning"
    review: "@scrum-event-sprint-review"
    retrospective: "@scrum-event-sprint-retrospective"
    refinement: "@scrum-event-backlog-refinement"
