# AI-Agentic Scrum Dashboard
# Single source of truth for all Scrum artifacts
# Git tracks when changes were made - no timestamps needed
# Order is priority - higher items have higher priority
# Historical details: git log -- scrum.yaml

---
# ==============================================================================
# RULES (Condensed)
# ==============================================================================

rules:
  core:
    - "Single Source of Truth: This dashboard is the only place for Scrum artifacts"
    - "Git as History: Do not add timestamps. Use git log for history"
    - "Order is Priority: Items higher in lists have higher priority"
    - "1 Sprint = 1 PBI: Each Sprint delivers exactly one PBI"

  definition_of_ready:
    summary: "Ready = AI can complete it without asking humans"
    flow: "draft -> refining -> ready"

  tdd_workflow:
    cycle: "pending -> red (commit) -> green (commit) -> refactoring (commit) -> completed"
    discipline: "ONE commit per TDD phase. Never mix behavioral and structural changes"

  agent_responsibilities:
    product_owner: "Product Backlog, Product Goal, Sprint acceptance"
    scrum_master: "Sprint config, Impediments, Retrospective, Metrics"
    developer: "Subtask status, Progress, Notes, Impediments"

---
# ==============================================================================
# QUICK STATUS
# ==============================================================================

quick_status:
  current_sprint: "Sprint 43 - COMPLETED - PBI-059 (1pt) - Consistent naming in injection.rs"
  backlog: "1 PBI ready (tidying)"
  impediments: 0

---
# ==============================================================================
# PRODUCT GOAL
# ==============================================================================

product_goal:
  statement: "Enable zero-configuration usage of treesitter-ls: users can start the LSP server and get syntax highlighting for any supported language without manual setup."
  mvp_status: COMPLETE
  mvp_definition: |
    Minimum Viable Zero-Config Experience:
    1. User starts treesitter-ls with no initialization options
    2. User opens a .lua file (or any supported language)
    3. treesitter-ls automatically:
       a. Detects the language from file extension (via LSP languageId)
       b. Installs the parser and queries if missing (autoInstall: true by default)
       c. Uses default searchPaths (~/.local/share/treesitter-ls)
       d. Provides semantic highlighting
    4. Power users can still override with explicit configuration
  owner: "@scrum-team-product-owner"

---
# ==============================================================================
# PRODUCT BACKLOG (Active Items Only)
# ==============================================================================
# Completed PBIs: PBI-001 through PBI-041
# For details: git log -- scrum.yaml

product_backlog:
  # ============================================================================
  # Technical Debt / Maintenance (Highest Priority)
  # ============================================================================

  - id: PBI-049
    story:
      role: "user starting treesitter-ls with default settings"
      capability: "get working syntax highlighting when parsers already exist"
      benefit: "zero-config experience works reliably without explicit autoInstall=false"
    status: done
    story_points: 3
    acceptance_criteria:
      - criterion: "AC1: Auto-install treats AlreadyExists as success, not failure"
        verification: |
          # Unit test verifies AlreadyExists triggers reload:
          cargo test test_already_exists_triggers_reload -- --nocapture
          # Or verify via log output that reload is called when parser exists
      - criterion: "AC2: E2E tests pass with default autoInstall (empty init_options)"
        verification: |
          # Ensure minimal_init.lua uses init_options = {} (no autoInstall setting)
          # Then run E2E tests:
          make test_nvim
          # Expected: All tests pass when parser already exists
      - criterion: "AC3: Existing tests continue to pass"
        verification: "make test && make check"
    notes: |
      ## Root Cause Analysis
      When autoInstall is enabled (default) and parser already exists:
      1. install_parser() returns Err(AlreadyExists)
      2. InstallResult.is_success() returns false
      3. reload_language_after_install() is NOT called
      4. Parser never gets loaded into coordinator

      With autoInstall=false, the auto-install path is skipped entirely,
      so normal loading works correctly.

      ## Fix Options (in order of preference)
      C) Skip install_parser if parser file exists (check before calling)
         - Simplest: avoids calling install_parser entirely
         - Check parser_file.exists() before install_language_async
      B) Check for AlreadyExists error and still call reload_language_after_install
         - Requires matching on error message string (fragile)
      A) Treat AlreadyExists as partial success in InstallResult
         - Changes InstallResult semantics (may have side effects)

      ## Files Affected
      - src/lsp/lsp_impl.rs (maybe_auto_install_language function)
      - src/install/mod.rs (InstallResult if option A chosen)
      - src/install/parser.rs (AlreadyExists error definition)

      ## TDD Approach
      1. RED: Write test that triggers auto-install when parser exists
      2. GREEN: Implement fix (option C recommended)
      3. REFACTOR: Clean up any redundant checks

  - id: PBI-051
    story:
      role: "user configuring treesitter-ls in Neovim"
      capability: "omit init_options entirely from LSP config"
      benefit: "simplest possible zero-config setup works out of the box"
    status: done
    story_points: 1
    acceptance_criteria:
      - criterion: "AC1: E2E tests pass when init_options is completely omitted"
        verification: |
          # Ensure minimal_init.lua has NO init_options line
          grep -v "init_options" scripts/minimal_init.lua | head -5
          make test_nvim
          # Expected: All tests pass
      - criterion: "AC2: Existing tests continue to pass"
        verification: "make test && make check"
    notes: |
      ## Root Cause Analysis
      When init_options is omitted, Neovim sends initializationOptions = {} (empty dict).
      The server parses this successfully, but search_paths is None/empty.

      The bug is in reload_language_after_install() at lsp_impl.rs:360-370:
      - It adds "data_dir/parsers" (plural) to search paths
      - But parser files are installed at "data_dir/parser" (singular)
      - So the language coordinator can't find the parser

      ## Fix
      Change lsp_impl.rs line 360: "parsers" -> "parser"
      (queries at line 367 is already correct)

      ## Files Affected
      - src/lsp/lsp_impl.rs:360 - fix typo: parsers -> parser

  - id: PBI-050
    story:
      role: "user running treesitter-ls"
      capability: "see query predicate issues at info level instead of warn"
      benefit: "log output distinguishes between actionable warnings and informational messages"
    status: done
    story_points: 1
    acceptance_criteria:
      - criterion: "AC1: All 5 query predicate log calls use info! instead of warn!"
        verification: |
          # query_predicates.rs: 3 info! calls, 0 warn! calls
          [ $(grep -c "info!" src/language/query_predicates.rs) -eq 3 ]
          [ $(grep -c "warn!" src/language/query_predicates.rs) -eq 0 ]
          # injection.rs: 2 info! calls for query-related messages
          grep -c "info!" src/language/injection.rs  # Expected: 2
      - criterion: "AC2: Log target remains treesitter_ls::query for all calls"
        verification: |
          grep "treesitter_ls::query" src/language/query_predicates.rs
          grep "treesitter_ls::query" src/language/injection.rs
      - criterion: "AC3: Documentation updated in docs/README.md"
        verification: |
          # Log table should show info level for treesitter_ls::query
          grep "treesitter_ls::query" docs/README.md | grep -q "info"
      - criterion: "AC4: All tests pass"
        verification: "make test && make check"
    notes: |
      ## Rationale (Dave Cheney's logging philosophy)
      - warn implies user action is needed
      - Most users cannot modify upstream nvim-treesitter queries
      - These messages are informational for query authors, not actionable warnings
      - info is appropriate for "interesting runtime events"

      ## Files Affected (5 log calls + 1 doc)
      - src/language/query_predicates.rs: 3 calls (lines 31, 39, 47)
        - Change: use log::warn -> use log::info
        - Change: warn! -> info! (3 occurrences)
      - src/language/injection.rs: 2 calls (lines 57, 108)
        - Change: log::warn! -> log::info! (2 occurrences)
      - docs/README.md: Update logging table row for treesitter_ls::query
        - Change: warn -> info in Level column

  # ============================================================================
  # Tidying / Code Quality (Kent Beck's Tidy First)
  # ============================================================================

  - id: PBI-052
    story:
      role: "developer maintaining treesitter-ls"
      capability: "remove unused code from position.rs and semantic.rs modules"
      benefit: "reduced technical debt and clearer codebase"
    status: done
    story_points: 1
    acceptance_criteria:
      - criterion: "AC1: compute_line_starts() function removed from position.rs"
        verification: |
          # Function should not exist in position.rs
          ! grep -q "pub fn compute_line_starts" src/text/position.rs
          # No other files should reference it
          ! grep -r "compute_line_starts" src/ --include="*.rs" | grep -v "^Binary"
      - criterion: "AC2: _text field removed from PositionMapper struct"
        verification: |
          # Field should not exist (check for _text in struct definition)
          ! grep -q "_text:" src/text/position.rs
          # PositionMapper::new should not store text
          grep -A5 "pub fn new" src/text/position.rs | grep -q "line_index"
      - criterion: "AC3: Domain* semantic token re-exports removed from semantic.rs"
        verification: |
          # Re-exports should not exist (lines 10-17)
          ! grep -q "DomainSemantic" src/analysis/semantic.rs
          # No other files should reference them
          ! grep -r "DomainSemantic" src/ --include="*.rs"
      - criterion: "AC4: All tests pass"
        verification: "make test && make check"
    notes: |
      ## Dead Code Identified
      - compute_line_starts() in text/position.rs:77-90 - exported but never used externally
      - _text field in PositionMapper - stored but never accessed (line_index is used instead)
      - DomainSemantic* re-exports in analysis/semantic.rs:10-17 - aliased but never used

      ## Risk: Very Low
      - Pure removal of unused code
      - No behavioral changes
      - Straightforward verification via grep

  - id: PBI-053
    story:
      role: "developer maintaining treesitter-ls"
      capability: "use consistent path resolution in query_loader.rs"
      benefit: "avoid subtle bugs from inconsistent path handling"
    status: done
    story_points: 1
    acceptance_criteria:
      - criterion: "AC1: All extension checks use PathBuf with .clean()"
        verification: |
          # Check that .dll path uses PathBuf.clean() like .so and .dylib
          grep -A3 "dll" src/language/query_loader.rs | grep -q "PathBuf"
          grep -A3 "dll" src/language/query_loader.rs | grep -q ".clean()"
      - criterion: "AC2: Extension search consolidated to loop over PARSER_EXTENSIONS array"
        verification: |
          # Check for PARSER_EXTENSIONS constant definition
          grep -q "PARSER_EXTENSIONS" src/language/query_loader.rs
          # Check that it contains all three extensions
          grep "PARSER_EXTENSIONS" src/language/query_loader.rs | grep -q "so.*dylib.*dll\|dylib.*so.*dll"
      - criterion: "AC3: resolve_library_path test passes with Windows paths"
        verification: |
          # Existing test should still pass
          cargo test test_resolve_library_path -- --nocapture
      - criterion: "AC4: All tests pass"
        verification: "make test && make check"
    notes: |
      ## Issue
      query_loader.rs:250-252 uses format!() without .clean() while other extensions use PathBuf:
      ```rust
      // .so uses: PathBuf::from(path).join("parser").join(format!("{language}.so")).clean();
      // .dylib uses: PathBuf::from(path).join("parser").join(format!("{language}.dylib")).clean();
      // .dll uses: format!("{path}/parser/{language}.dll") -- INCONSISTENT
      ```

      ## Fix
      Consolidate to:
      ```rust
      const PARSER_EXTENSIONS: &[&str] = &["so", "dylib", "dll"];
      for ext in PARSER_EXTENSIONS {
          let path = PathBuf::from(base).join("parser").join(format!("{language}.{ext}")).clean();
          if path.exists() { return Some(path.to_string_lossy().into_owned()); }
      }
      ```

      ## Risk: Very Low
      - Simple refactor for consistency
      - Existing behavior preserved

  # ============================================================================
  # Removed DRY PBIs after review - premature abstraction risk
  # ============================================================================
  # PBI-054 (lock recovery helper): Duplication is intentional - each log message
  #   has unique context for debugging. Generic helper would obscure failures.
  # PBI-055 (coordinator lock fix): Depended on PBI-054. The 2 .unwrap() calls
  #   are acceptable - coordinator failures are unrecoverable anyway.
  # PBI-056 (line-finding helper): Only 2 instances with different semantics
  #   (forward vs backward scan). Not true duplication.
  # PBI-057 (injection query helper): Different extraction logic, filter criteria,
  #   and return types. Looks similar but fundamentally different purposes.
  # PBI-058 (split lsp_impl.rs): Too complex, revisit later.
  # ============================================================================

  - id: PBI-059
    story:
      role: "developer maintaining treesitter-ls"
      capability: "understand injection language extraction flow more easily"
      benefit: "improved clarity in injection.rs"
    status: done
    story_points: 1
    acceptance_criteria:
      - criterion: "AC1: Consistent function naming (extract_* for extraction, collect_* for collection)"
        verification: |
          # Check naming convention:
          # - extract_* functions should extract single items from matches
          # - collect_* functions should gather multiple items
          grep -E "^(pub )?fn (extract_|collect_|find_)" src/language/injection.rs
          # No mixed naming like find_injection_content_and_language
          ! grep -q "fn find_injection_content_and_language" src/language/injection.rs
      - criterion: "AC2: Function names clearly indicate their return type"
        verification: |
          # Functions returning Option<String> should be named extract_*
          # Functions returning Vec<...> should be named collect_*
          grep "fn extract_" src/language/injection.rs | head -3
          grep "fn collect_" src/language/injection.rs | head -3
      - criterion: "AC3: All injection tests pass"
        verification: |
          cargo test injection -- --nocapture
          make test && make check
    notes: |
      ## Issue
      injection.rs has inconsistent naming patterns:
      - extract_injection_language() - extracts language string
      - collect_all_injections() - collects multiple regions
      - find_injection_content_and_language() - extracts tuple (mixed naming)

      ## Proposed Naming Convention
      - `extract_*` - Single item extraction from a match
      - `collect_*` - Multiple item collection with deduplication
      - Remove `find_*` pattern for consistency

      ## Rename Plan
      - find_injection_content_and_language -> extract_content_and_language

      ## Risk: Very Low
      - Pure naming refactor
      - All functions are private (internal to injection.rs)
      - No API changes

      ## Files Affected
      - src/language/injection.rs

  - id: PBI-060
    story:
      role: "developer maintaining treesitter-ls"
      capability: "see clearer test coverage for injection malformed directives"
      benefit: "improved test clarity and maintainability"
    status: ready
    story_points: 1
    acceptance_criteria:
      - criterion: "AC1: test_malformed_offset_directives split into 5 focused tests"
        verification: |
          # Original monolithic test should not exist
          ! grep -q "fn test_malformed_offset_directives" src/language/injection.rs
          # Should have 5 separate tests for malformed scenarios
          [ $(grep -c "fn test_offset.*\|fn test_malformed" src/language/injection.rs) -ge 5 ]
      - criterion: "AC2: Each test has descriptive name for the scenario"
        verification: |
          # Test names should describe the scenario being tested
          grep "fn test_" src/language/injection.rs | grep -E "non_numeric|missing_args|too_many|mixed_valid|empty_directive"
      - criterion: "AC3: All 5 malformed directive scenarios covered"
        verification: |
          # Run the new tests
          cargo test test_offset -- --nocapture
          cargo test test_malformed -- --nocapture
          # All tests should pass
          make test && make check
    notes: |
      ## Issue
      injection.rs:650-736 test_malformed_offset_directives() is 86 lines testing 5 scenarios:
      1. Non-numeric offset values (foo bar baz qux)
      2. Missing offset arguments (only 2 instead of 4)
      3. Too many offset arguments (5 instead of 4)
      4. Mixed valid and invalid values
      5. Empty offset directive (no arguments after capture)

      ## Solution
      Split into 5 separate tests with descriptive names:
      ```rust
      #[test]
      fn test_offset_directive_with_non_numeric_values() { ... }

      #[test]
      fn test_offset_directive_with_missing_arguments() { ... }

      #[test]
      fn test_offset_directive_with_extra_arguments() { ... }

      #[test]
      fn test_offset_directive_with_mixed_valid_invalid() { ... }

      #[test]
      fn test_offset_directive_with_empty_args() { ... }
      ```

      ## Benefits
      - Each test failure clearly indicates which scenario failed
      - Easier to add new test cases
      - Better test documentation through function names

      ## Risk: Very Low
      - Pure test refactoring
      - No production code changes
      - Same coverage, better organization

      ## Files Affected
      - src/language/injection.rs (test module only)

  # ============================================================================
  # ADR-0003: Parser Compilation Fallback Strategy - SUPERSEDED
  # Decision: Keep tree-sitter-cli as sole compilation dependency
  # Rationale: Matches nvim-treesitter approach, avoids header management complexity
  # PBI-045, PBI-046, PBI-047, PBI-048 removed from backlog
  # ============================================================================

---
# ==============================================================================
# DEFINITION OF READY
# ==============================================================================

definition_of_ready:
  criteria:
    - "AI can complete this story without human input"
    - "User story has role, capability, and benefit"
    - "At least 3 acceptance criteria with verification commands"
    - "Dependencies are resolved or not blocking"

---
# ==============================================================================
# DEFINITION OF DONE
# ==============================================================================

definition_of_done:
  checks:
    - name: "All unit tests pass"
      run: "make test"
    - name: "Code quality checks pass"
      run: "make check"
    - name: "E2E tests pass"
      run: "make test_nvim"

---
# ==============================================================================
# CURRENT SPRINT
# ==============================================================================

current_sprint:
  sprint: 43
  pbi: PBI-059
  goal: "Apply consistent naming convention in injection.rs: extract_* for single item extraction, collect_* for multiple item collection"
  status: completed

  subtasks:
    - id: ST-059-1
      title: "Rename find_injection_content_and_language to extract_content_and_language"
      status: completed
      commits:
        - "5489919 - refactor(injection): rename find_injection_content_and_language to extract_content_and_language"

    - id: ST-059-2
      title: "Verify naming convention is consistent (extract_* for extraction, collect_* for collection)"
      status: completed
      commits: []

    - id: ST-059-3
      title: "Verify all tests pass"
      status: completed
      commits: []

  notes: |
    ## Sprint Goal
    Apply consistent naming convention in injection.rs to improve code clarity.
    The find_injection_content_and_language function should be renamed to extract_content_and_language
    to match the extract_* pattern used by other extraction functions.

    ## Naming Convention
    - extract_* - Single item extraction from a match (returns Option<T>)
    - collect_* - Multiple item collection with deduplication (returns Vec<T>)
    - find_* pattern should be removed for consistency (only test helper retains find_*)

    ## Files Affected
    - src/language/injection.rs (internal rename only, all functions are private)

    ## Final State
    - extract_* functions: 5 (single item extraction)
    - collect_* functions: 2 (multiple item collection)
    - find_* in main code: 0 (only test helper find_node_at_byte remains)

---
# ==============================================================================
# COMPLETED SPRINTS (Summary Only)
# ==============================================================================
# For detailed subtasks and commits: git log -- scrum.yaml

completed_sprints:
  - sprint: 43
    pbi: PBI-059
    outcome: "Applied consistent naming convention in injection.rs: extract_* for extraction, collect_* for collection"
    retrospective:
      what_went_well:
        - "Clean single-commit refactoring (5489919)"
        - "All 199 unit tests pass, clippy clean, formatting clean"
        - "Naming convention now consistent across all 7 functions"
        - "Pure structural change with zero behavioral impact"
      what_to_improve:
        - "Consider documenting naming conventions in module-level docs"
      insight: |
        Naming consistency refactors are low-risk tidying activities that improve code
        readability. The extract_*/collect_* naming convention clearly communicates
        function behavior: extract returns Option<T> for single items, collect returns
        Vec<T> for multiple items. Test helpers can retain different naming (find_*)
        since they serve a different purpose and are not part of the module's API.

  - sprint: 42
    pbi: PBI-053
    outcome: "Consolidated path resolution in query_loader.rs with PARSER_EXTENSIONS array (22 lines to 11 lines)"
    retrospective:
      what_went_well:
        - "All 4 subtasks completed in single cohesive refactoring commit"
        - "Code reduction from 3 separate if-blocks (22 lines) to single loop (11 lines)"
        - "All Definition of Done checks passed (199 unit tests)"
        - "Consistent PathBuf with .clean() handling across all platforms"
      what_to_improve:
        - "Consider adding more platform-specific tests for Windows path handling"
      insight: |
        Loop-based consolidation is a classic DRY refactoring pattern. When multiple
        code blocks differ only by a constant value (extension string), extracting
        those values into an array and iterating is both safer and more maintainable.
        The PARSER_EXTENSIONS constant also serves as documentation of supported platforms.

  - sprint: 41
    pbi: PBI-052
    outcome: "Removed dead code from position.rs and semantic.rs (compute_line_starts, _text field, DomainSemantic re-exports)"
    retrospective:
      what_went_well:
        - "All 4 subtasks completed in single cohesive refactoring commit"
        - "All acceptance criteria verified via grep commands"
        - "All Definition of Done checks passed (199 unit tests)"
        - "Pure structural change with zero behavioral impact"
      what_to_improve:
        - "Consider running dead code analysis periodically to catch unused code earlier"
      insight: |
        Dead code removal is a straightforward tidying activity that naturally completes
        in a single commit. When code is demonstrably unused (no callers, no references),
        removal is low-risk and improves codebase clarity. Verification via grep provides
        high confidence that removed code was truly dead.

  - sprint: 40
    pbi: PBI-050
    outcome: "Changed query predicate log level from warn to info for better log hygiene and actionability"
    retrospective:
      what_went_well:
        - "Clear rationale based on Dave Cheney's logging philosophy"
        - "Simple, focused refactoring with single cohesive commit"
        - "All Definition of Done checks passed (199 unit tests + 20 E2E tests)"
        - "Documentation updated alongside code changes"
      what_to_improve:
        - "Initial PBI notes incorrectly stated warn! macros existed when actual code used eprintln!"
      insight: |
        Log level decisions should be based on actionability, not severity. Warnings imply
        user action is needed, while info is for interesting but non-actionable events.
        Query predicate issues are informational for query authors (who use nvim-treesitter),
        not actionable for end users of treesitter-ls. This distinction keeps RUST_LOG=warn
        output focused on truly actionable issues.

  - sprint: 39
    pbi: PBI-051
    outcome: "Fixed zero-config to work when init_options is completely omitted from Neovim LSP config"
    retrospective:
      what_went_well:
        - "Identified the deeper issue beyond the initial typo analysis"
        - "Single cohesive commit fixed all related issues (typo + initialization)"
        - "All Definition of Done checks passed (199 unit tests + 20 E2E tests)"
        - "Root cause analysis refined during implementation"
      what_to_improve:
        - "Initial PBI analysis was surface-level (typo) rather than systemic (initialization flow)"
      insight: |
        Bug analysis should examine the full execution flow, not just the immediate error location.
        The PBI identified a typo ("parsers" vs "parser"), but testing revealed the deeper issue:
        when no settings are loaded, apply_settings() was never called, leaving auto_install=false.
        Derived Default traits don't always match business requirements - zero-config requires
        auto_install=true, but bool's Default is false. The fix ensures settings are always
        applied with proper business defaults via the From<TreeSitterSettings> conversion.

  - sprint: 38
    pbi: PBI-049
    outcome: "Fixed zero-config auto-install when parsers already exist by adding parser_file_exists check before installation"
    retrospective:
      what_went_well:
        - "Root cause identified correctly - AlreadyExists error prevented reload"
        - "Simple, targeted fix (Option C) avoided complex changes to InstallResult"
        - "Discovered and fixed secondary bug with Lua empty table JSON serialization"
        - "All Definition of Done checks passed"
      what_to_improve:
        - "Consider adding integration test for the specific scenario (parser exists + autoInstall enabled)"
      insight: |
        When fixing auto-install issues, check the full flow from installation attempt through
        to language loading. The fix point was at the beginning (check before install) rather
        than at the error handling (treating AlreadyExists as success), which was simpler and
        less risky. Also discovered that vim.empty_dict() is needed for proper JSON object
        serialization from Lua.

  - sprint: 37
    pbi: PBI-041
    outcome: "Consolidated QueryLoader API to single resolve_query entry point, renamed from resolve_query_with_inheritance"
    retrospective:
      what_went_well:
        - "All acceptance criteria passed on first verification"
        - "All Definition of Done checks passed"
        - "Clean, focused single-commit refactoring (a9fb827)"
      what_to_improve:
        - "Start Sprint Planning earlier when work is identified"
      insight: |
        Consolidation-type PBIs (API simplification, cleanup) naturally complete in single
        well-scoped refactoring commits. This is appropriate for pure structural changes
        with no behavioral changes - not a TDD violation but recognition of a distinct pattern.
  - sprint: 36
    pbi: PBI-044
    outcome: "Replaced hardcoded CONFIG_TEMPLATE with type-safe default_settings() serialization (90+ mappings)"
  - sprint: 35
    pbi: PBI-043
    outcome: "Changed config init to output to stdout by default, added --output flag for file creation"
  - sprint: 34
    pbi: PBI-042
    outcome: "Simplified CONFIG_TEMPLATE to minimal active TOML (doc link comment + active settings)"
  - sprint: 33
    pbi: PBI-040
    outcome: "Consolidated offset calculation API by removing redundant function and renaming to single calculate_effective_range"
  - sprint: 32
    pbi: PBI-039
    outcome: "Removed test-only wrapper functions, migrated 18 test call sites to CodeActionOptions builder"
  - sprint: 31
    pbi: PBI-033
    outcome: "Consolidated code action functions to single entry point with CodeActionOptions builder pattern"
  - sprint: 30
    pbi: PBI-032
    outcome: "Split lsp_impl.rs from 2327 to 1299 lines by extracting auto_install module"
  - sprint: 29
    pbi: PBI-038
    outcome: "Documented logging targets (lock_recovery, crash_recovery, query) in README"
  - sprint: 28
    pbi: PBI-036
    outcome: "Consolidated recover_poison() with context parameter, removed context-less variant"
  - sprint: 27
    pbi: PBI-037
    outcome: "Changed crash detection logging from warn to error level"
  - sprint: 26
    pbi: PBI-035
    outcome: "Standardized log targets across all log::warn! calls"
  - sprint: 25
    pbi: PBI-034
    outcome: "Initialized logging backend with env_logger, enabling RUST_LOG configuration"
  - sprint: 24
    pbi: PBI-031
    outcome: "Added phase markers in handle_semantic_tokens_full for better readability"
  - sprint: 23
    pbi: PBI-030
    outcome: "Standardized lock handling with LockResultExt trait, reduced duplication"
  - sprint: 22
    pbi: PBI-029
    outcome: "Removed dead code: deprecated functions, placeholder tests, stale annotations"
  - sprint: 21
    pbi: PBI-028
    outcome: "Fixed default_search_paths() to return base directory, enabling zero-config mode"
  - sprint: 20
    pbi: PBI-027
    outcome: "Fixed markdown selection range test expectation to match AST structure"
  - sprint: 19
    pbi: PBI-024
    outcome: "Added language uninstall command with confirmation prompt and --all flag"
  - sprint: 18
    pbi: PBI-023
    outcome: "Added language status command to show installed languages and missing components"
  - sprint: 17
    pbi: PBI-022
    outcome: "Added config init command to generate treesitter-ls.toml template"
  - sprint: 16
    pbi: PBI-021
    outcome: "Added Prerequisites section to docs/README.md with dependency requirements"
  - sprint: 15
    pbi: PBI-026
    outcome: "CLI migrated to hierarchical structure: treesitter-ls language {install,list}"
  - sprint: 14
    pbi: PBI-025
    outcome: "ADR documentation with template and ADR-0001 (hierarchical CLI subcommands)"
  - sprint: 13
    pbi: PBI-020
    outcome: "Query inheritance support via parse_inherits_directive() and resolve_query_with_inheritance()"
  - sprint: 12
    pbi: PBI-016
    outcome: "Parser crash resilience via state file detection and CLI recovery"
  - sprint: 11
    pbi: PBI-010
    outcome: "Cache parsers.lua locally with 1-hour TTL and --no-cache flag"
  - sprint: 10
    pbi: PBI-015
    outcome: "Fixed git checkout for tag revisions using FETCH_HEAD"
  - sprint: 9
    pbi: [PBI-017, PBI-018, PBI-019]
    outcome: "Zero-Config MVP complete - default searchPaths, autoInstall=true by default"
  - sprint: 8
    pbi: PBI-013
    outcome: "Auto-install for injected languages on file open"
  - sprint: 7
    pbi: PBI-008
    outcome: "Auto-install infrastructure (silent background install)"
  - sprint: 6
    pbi: PBI-009
    outcome: "Combined install command (parser + queries)"
  - sprint: 5
    pbi: PBI-006
    outcome: "Parser compilation via tree-sitter CLI"
  - sprint: 4
    pbi: PBI-005
    outcome: "Query downloading from nvim-treesitter"
  - sprint: 3
    pbi: PBI-004
    outcome: "CLI infrastructure with clap"
  - sprint: 2
    pbi: PBI-002
    outcome: "Unified semantic token handlers; fixed PBI-003"
  - sprint: 1
    pbi: PBI-001
    outcome: "Semantic tokens for injected languages"

---
# ==============================================================================
# IMPEDIMENTS
# ==============================================================================

impediments:
  active: []
  # Format: {id, description, impact, severity, status}

---
# ==============================================================================
# AGENTS
# ==============================================================================

agents:
  roles:
    product_owner: "@scrum-team-product-owner"
    scrum_master: "@scrum-team-scrum-master"
    developer: "@scrum-team-developer"
  events:
    planning: "@scrum-event-sprint-planning"
    review: "@scrum-event-sprint-review"
    retrospective: "@scrum-event-sprint-retrospective"
    refinement: "@scrum-event-backlog-refinement"
