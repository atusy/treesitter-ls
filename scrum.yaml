# AI-Agentic Scrum Dashboard
# Single source of truth for all Scrum artifacts
# Git tracks when changes were made - no timestamps needed
# Order is priority - higher items have higher priority
# Historical details: git log -- scrum.yaml

---
# ==============================================================================
# RULES (Condensed)
# ==============================================================================

rules:
  core:
    - "Single Source of Truth: This dashboard is the only place for Scrum artifacts"
    - "Git as History: Do not add timestamps. Use git log for history"
    - "Order is Priority: Items higher in lists have higher priority"
    - "1 Sprint = 1 PBI: Each Sprint delivers exactly one PBI"

  definition_of_ready:
    summary: "Ready = AI can complete it without asking humans"
    flow: "draft -> refining -> ready"

  tdd_workflow:
    cycle: "pending -> red (commit) -> green (commit) -> refactoring (commit) -> completed"
    discipline: "ONE commit per TDD phase. Never mix behavioral and structural changes"

  agent_responsibilities:
    product_owner: "Product Backlog, Product Goal, Sprint acceptance"
    scrum_master: "Sprint config, Impediments, Retrospective, Metrics"
    developer: "Subtask status, Progress, Notes, Impediments"

---
# ==============================================================================
# QUICK STATUS
# ==============================================================================

quick_status:
  current_sprint:
    number: 12
    pbi: PBI-016
    status: done
    goal: "Parser crash resilience via state file detection"
  impediments: 0

---
# ==============================================================================
# PRODUCT GOAL
# ==============================================================================

product_goal:
  statement: "Enable zero-configuration usage of treesitter-ls: users can start the LSP server and get syntax highlighting for any supported language without manual setup."
  mvp_status: COMPLETE
  mvp_definition: |
    Minimum Viable Zero-Config Experience:
    1. User starts treesitter-ls with no initialization options
    2. User opens a .lua file (or any supported language)
    3. treesitter-ls automatically:
       a. Detects the language from file extension (via LSP languageId)
       b. Installs the parser and queries if missing (autoInstall: true by default)
       c. Uses default searchPaths (~/.local/share/treesitter-ls/{parser,queries})
       d. Provides semantic highlighting
    4. Power users can still override with explicit configuration
  owner: "@scrum-team-product-owner"

---
# ==============================================================================
# PRODUCT BACKLOG (Active Items Only)
# ==============================================================================
# Completed PBIs: PBI-001 through PBI-010, PBI-013 through PBI-016, PBI-017, PBI-018, PBI-019
# For details: git log -- scrum.yaml

product_backlog:
  # Priority 1: Bug fix for parser installation
  - id: PBI-015
    status: done
    story:
      role: "user of treesitter-ls"
      capability: "install parsers at specific git revisions (tags or commit hashes)"
      benefit: "I can reliably install parsers using nvim-treesitter's pinned revisions"
    acceptance_criteria:
      - criterion: "Installing a parser with a tag revision (e.g., v0.25.0) succeeds"
        verification: |
          rm -rf /tmp/test-python
          ./target/release/treesitter-ls install python --data-dir /tmp/test-python --verbose
          test -f /tmp/test-python/parser/python.dylib || test -f /tmp/test-python/parser/python.so
      - criterion: "Installing a parser with a commit hash revision succeeds"
        verification: |
          rm -rf /tmp/test-lua
          ./target/release/treesitter-ls install lua --data-dir /tmp/test-lua --verbose
          test -f /tmp/test-lua/parser/lua.dylib || test -f /tmp/test-lua/parser/lua.so
      - criterion: "Verbose output shows which revision was checked out"
        verification: |
          ./target/release/treesitter-ls install lua --data-dir /tmp/test-verbose --verbose --force 2>&1 | grep -i "revision"
    story_points: 1
    technical_notes: |
      Bug: git checkout <tag> fails in shallow clone after git fetch --depth 1 origin <tag>
      Fix: Use "git checkout FETCH_HEAD" instead of "git checkout <revision>"
      File: src/install/parser.rs - clone_repo() function

  # Priority 2: Performance improvement
  - id: PBI-010
    status: done
    story:
      role: "user of treesitter-ls"
      capability: "have parsers.lua cached locally to avoid repeated HTTP requests"
      benefit: "I can run multiple install commands quickly without waiting for network requests"
    acceptance_criteria:
      - criterion: "Second install command in same session reuses cached parsers.lua"
        verification: "Time two consecutive installs - second should be faster"
      - criterion: "Cache expires after 1 hour (configurable)"
        verification: "Verify cache TTL behavior through code review/unit tests"
      - criterion: "Cache can be bypassed with --no-cache flag"
        verification: "./target/release/treesitter-ls install lua --no-cache 2>&1 | grep -i fetch"
      - criterion: "Cache is stored in data directory"
        verification: "test -f /tmp/cache-test/cache/parsers.lua"
    story_points: 3

  # Priority 3: Robustness improvement
  - id: PBI-016
    status: done
    story:
      role: "user of treesitter-ls"
      capability: "continue using the language server even when a parser crashes"
      benefit: "I don't lose all functionality just because one language parser has a bug"
    acceptance_criteria:
      - criterion: "Server remains running when a parser triggers an assertion failure"
      - criterion: "Failed parser is marked as unavailable and won't crash again"
      - criterion: "Error message is logged with sufficient detail for debugging"
      - criterion: "Other languages continue to work normally after one parser crashes"
      - criterion: "Crashed parser can be retried after reinstallation"
    story_points: 8
    technical_notes: |
      Solution: State file crash detection (simpler than subprocess isolation)
      - Before parsing: write language to "parsing_in_progress" state file
      - After success: remove state file
      - On restart: if state file exists, mark that parser as crashed
      - CLI command: treesitter-ls crash-recovery {list,clear}
      - Failed parsers are skipped until user clears via CLI after reinstall

  # Priority 4: UX improvement (draft)
  - id: PBI-011
    status: draft
    story:
      role: "user of treesitter-ls"
      capability: "install multiple languages with a single command"
      benefit: "I can set up my development environment quickly without running separate commands"
    acceptance_criteria:
      - criterion: "treesitter-ls install lua rust python installs all three"
      - criterion: "Progress shows which language is being installed (1/3, 2/3, 3/3)"
      - criterion: "If one language fails, others are still attempted"
      - criterion: "Summary shows success/failure count at the end"
    story_points: 3
    dependencies: [PBI-010]

  # Priority 5: Nice-to-have (draft)
  - id: PBI-012
    status: draft
    story:
      role: "user of treesitter-ls"
      capability: "see progress indicators during parser compilation"
      benefit: "I know the install is working and approximately how long it will take"
    acceptance_criteria:
      - criterion: "Parser compilation shows phases (cloning, building, installing)"
      - criterion: "Long operations show spinner or elapsed time"
      - criterion: "Quiet mode (--quiet) suppresses progress output"
    story_points: 2

---
# ==============================================================================
# DEFINITION OF READY
# ==============================================================================

definition_of_ready:
  criteria:
    - "AI can complete this story without human input"
    - "User story has role, capability, and benefit"
    - "At least 3 acceptance criteria with verification commands"
    - "Dependencies are resolved or not blocking"

---
# ==============================================================================
# DEFINITION OF DONE
# ==============================================================================

definition_of_done:
  checks:
    - name: "All unit tests pass"
      run: "make test"
    - name: "Code quality checks pass"
      run: "make check"
    - name: "E2E tests pass"
      run: "make test_nvim"

---
# ==============================================================================
# CURRENT SPRINT
# ==============================================================================

current_sprint:
  number: 12
  pbi: PBI-016
  status: done
  goal: "Parser crash resilience via state file detection"

---
# ==============================================================================
# COMPLETED SPRINTS (Summary Only)
# ==============================================================================
# For detailed subtasks and commits: git log -- scrum.yaml

completed_sprints:
  - sprint: 12
    pbi: PBI-016
    outcome: "Parser crash resilience via state file detection and CLI recovery"
  - sprint: 11
    pbi: PBI-010
    outcome: "Cache parsers.lua locally with 1-hour TTL and --no-cache flag"
  - sprint: 10
    pbi: PBI-015
    outcome: "Fixed git checkout for tag revisions using FETCH_HEAD"
  - sprint: 9
    pbi: [PBI-017, PBI-018, PBI-019]
    outcome: "Zero-Config MVP complete - default searchPaths, autoInstall=true by default"
  - sprint: 8
    pbi: PBI-013
    outcome: "Auto-install for injected languages on file open"
  - sprint: 7
    pbi: PBI-008
    outcome: "Auto-install infrastructure (silent background install)"
  - sprint: 6
    pbi: PBI-009
    outcome: "Combined install command (parser + queries)"
  - sprint: 5
    pbi: PBI-006
    outcome: "Parser compilation via tree-sitter CLI"
  - sprint: 4
    pbi: PBI-005
    outcome: "Query downloading from nvim-treesitter"
  - sprint: 3
    pbi: PBI-004
    outcome: "CLI infrastructure with clap"
  - sprint: 2
    pbi: PBI-002
    outcome: "Unified semantic token handlers; fixed PBI-003"
  - sprint: 1
    pbi: PBI-001
    outcome: "Semantic tokens for injected languages"

---
# ==============================================================================
# IMPEDIMENTS
# ==============================================================================

impediments:
  active: []
  # Format: {id, description, impact, severity, status}

---
# ==============================================================================
# AGENTS
# ==============================================================================

agents:
  roles:
    product_owner: "@scrum-team-product-owner"
    scrum_master: "@scrum-team-scrum-master"
    developer: "@scrum-team-developer"
  events:
    planning: "@scrum-event-sprint-planning"
    review: "@scrum-event-sprint-review"
    retrospective: "@scrum-event-sprint-retrospective"
    refinement: "@scrum-event-backlog-refinement"
