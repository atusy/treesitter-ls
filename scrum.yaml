# AI-Agentic Scrum Dashboard
# Single source of truth for all Scrum artifacts
# Git tracks when changes were made - no timestamps needed
# Order is priority - higher items have higher priority
# Historical details: git log -- scrum.yaml

---
# ==============================================================================
# RULES (Condensed)
# ==============================================================================

rules:
  core:
    - "Single Source of Truth: This dashboard is the only place for Scrum artifacts"
    - "Git as History: Do not add timestamps. Use git log for history"
    - "Order is Priority: Items higher in lists have higher priority"
    - "1 Sprint = 1 PBI: Each Sprint delivers exactly one PBI"

  definition_of_ready:
    summary: "Ready = AI can complete it without asking humans"
    flow: "draft -> refining -> ready"

  tdd_workflow:
    cycle: "pending -> red (commit) -> green (commit) -> refactoring (commit) -> completed"
    discipline: "ONE commit per TDD phase. Never mix behavioral and structural changes"

  agent_responsibilities:
    product_owner: "Product Backlog, Product Goal, Sprint acceptance"
    scrum_master: "Sprint config, Impediments, Retrospective, Metrics"
    developer: "Subtask status, Progress, Notes, Impediments"

---
# ==============================================================================
# QUICK STATUS
# ==============================================================================

quick_status:
  current_sprint:
    number: 14
    pbi: PBI-025
    status: done
    goal: "Architecture Decision Records documentation"
  impediments: 0

---
# ==============================================================================
# PRODUCT GOAL
# ==============================================================================

product_goal:
  statement: "Enable zero-configuration usage of treesitter-ls: users can start the LSP server and get syntax highlighting for any supported language without manual setup."
  mvp_status: COMPLETE
  mvp_definition: |
    Minimum Viable Zero-Config Experience:
    1. User starts treesitter-ls with no initialization options
    2. User opens a .lua file (or any supported language)
    3. treesitter-ls automatically:
       a. Detects the language from file extension (via LSP languageId)
       b. Installs the parser and queries if missing (autoInstall: true by default)
       c. Uses default searchPaths (~/.local/share/treesitter-ls/{parser,queries})
       d. Provides semantic highlighting
    4. Power users can still override with explicit configuration
  owner: "@scrum-team-product-owner"

---
# ==============================================================================
# PRODUCT BACKLOG (Active Items Only)
# ==============================================================================
# Completed PBIs: PBI-001 through PBI-010, PBI-013 through PBI-016, PBI-017, PBI-018, PBI-019, PBI-020
# For details: git log -- scrum.yaml
#
product_backlog:
  # Priority 0: Architecture Decision Records
  - id: PBI-025
    status: done
    story:
      role: "developer or contributor of treesitter-ls"
      capability: "understand past architectural decisions and their rationale"
      benefit: "I can make informed decisions without repeating past mistakes or reversing good decisions"
    acceptance_criteria:
      - criterion: "docs/adr/ directory exists with ADR template"
        verification: |
          test -f docs/adr/0000-template.md
      - criterion: "ADR-0001 documents hierarchical CLI subcommand decision"
        verification: |
          test -f docs/adr/0001-hierarchical-cli-subcommands.md
          grep -E "treesitter-ls language install" docs/adr/0001-hierarchical-cli-subcommands.md
      - criterion: "ADRs follow standard format (Title, Status, Context, Decision, Consequences)"
        verification: |
          grep -E "^## (Status|Context|Decision|Consequences)" docs/adr/0001-hierarchical-cli-subcommands.md
    story_points: 1
    technical_notes: |
      ADR Format (based on Michael Nygard's template):
      ```markdown
      # ADR-NNNN: Title

      ## Status
      Accepted | Deprecated | Superseded by ADR-XXXX

      ## Context
      What is the issue that we're seeing that is motivating this decision?

      ## Decision
      What is the change that we're proposing and/or doing?

      ## Consequences
      What becomes easier or harder as a result of this change?
      ```

      First ADR: Hierarchical CLI Subcommands
      - Decision: Use `treesitter-ls <resource> <action>` pattern
      - Examples:
        - `treesitter-ls language install lua`
        - `treesitter-ls language uninstall lua`
        - `treesitter-ls language list`
        - `treesitter-ls language status`
        - `treesitter-ls config init`
      - Rationale: Scalable, discoverable, follows kubectl/docker patterns

  # Priority 1: Migrate existing CLI to hierarchical structure (FOUNDATIONAL)
  - id: PBI-026
    status: ready
    story:
      role: "user of treesitter-ls"
      capability: "use consistent hierarchical CLI commands"
      benefit: "I have a predictable, discoverable CLI that follows industry patterns"
    acceptance_criteria:
      - criterion: "treesitter-ls language install <lang> works"
        verification: |
          ./target/release/treesitter-ls language install lua --data-dir /tmp/test-migrate --force
          test -f /tmp/test-migrate/parser/lua.dylib || test -f /tmp/test-migrate/parser/lua.so
      - criterion: "treesitter-ls language list shows supported languages"
        verification: |
          ./target/release/treesitter-ls language list | grep -E "lua|rust|python"
      - criterion: "Old commands (install, list-languages) are removed"
        verification: |
          ! ./target/release/treesitter-ls install lua 2>&1 | grep -v "error"
          ! ./target/release/treesitter-ls list-languages 2>&1 | grep -v "error"
      - criterion: "Help text shows new hierarchical structure"
        verification: |
          ./target/release/treesitter-ls --help | grep "language"
          ./target/release/treesitter-ls language --help | grep -E "install|list"
    story_points: 3
    technical_notes: |
      CLI Migration:
      Before:
        treesitter-ls install <lang>
        treesitter-ls list-languages

      After:
        treesitter-ls language install <lang>
        treesitter-ls language list

      Implementation:
      1. Create Language subcommand enum with Install and List actions
      2. Move existing install logic to language::install
      3. Move existing list-languages logic to language::list
      4. Remove old top-level Install and ListLanguages commands
      5. Update docs/README.md with new CLI commands

      Breaking change: Old CLI commands will stop working.
      Note: Status and Uninstall will be added in PBI-023 and PBI-024.

  # Priority 2: Documentation - Dependencies
  - id: PBI-021
    status: ready
    story:
      role: "new user of treesitter-ls"
      capability: "know what external tools I need to install before using treesitter-ls"
      benefit: "I can set up my environment correctly and avoid cryptic error messages"
    acceptance_criteria:
      - criterion: "docs/README.md lists all required dependencies"
        verification: |
          grep -E "tree-sitter|git|C compiler" docs/README.md
      - criterion: "Each dependency includes installation instructions for major platforms"
        verification: |
          grep -E "brew|apt|cargo install" docs/README.md
      - criterion: "Error messages for missing dependencies are clear"
        verification: |
          # Remove tree-sitter temporarily and check error message
          ./target/release/treesitter-ls language install lua 2>&1 | grep -i "install"
    story_points: 1
    technical_notes: |
      Required external dependencies:
      1. tree-sitter CLI - for compiling parsers
         - Install: cargo install tree-sitter-cli
      2. Git - for cloning parser repositories
         - Usually pre-installed on most systems
      3. C compiler (cc/gcc/clang) - tree-sitter CLI needs this
         - macOS: xcode-select --install
         - Linux: apt install build-essential / dnf install gcc
         - Windows: Visual Studio Build Tools

      Files to update:
      - docs/README.md: Add "Prerequisites" section before "Zero-Configuration Usage"

  # Priority 3: Config generation CLI command
  - id: PBI-022
    status: ready
    story:
      role: "power user of treesitter-ls"
      capability: "generate a default configuration file"
      benefit: "I can customize settings without writing config from scratch"
    acceptance_criteria:
      - criterion: "treesitter-ls config init creates treesitter-ls.toml in current directory"
        verification: |
          cd /tmp && rm -f treesitter-ls.toml
          treesitter-ls config init
          test -f treesitter-ls.toml && echo "Config created"
      - criterion: "Generated config includes all available options with comments"
        verification: |
          grep -E "searchPaths|autoInstall|languages|captureMappings" /tmp/treesitter-ls.toml
      - criterion: "Existing config is not overwritten without --force"
        verification: |
          cd /tmp && echo "existing" > treesitter-ls.toml
          treesitter-ls config init 2>&1 | grep -i "exists"
          cat treesitter-ls.toml | grep "existing"
      - criterion: "--force overwrites existing config"
        verification: |
          cd /tmp && echo "existing" > treesitter-ls.toml
          treesitter-ls config init --force
          ! grep "existing" treesitter-ls.toml
    story_points: 2
    technical_notes: |
      CLI: treesitter-ls config init [--force]
      Output file: treesitter-ls.toml in current directory

      Implementation:
      1. Add Config subcommand with Init action to Commands enum
      2. Create run_config_init() function that writes template TOML
      3. Check if file exists, error unless --force

      Template content (TOML with comments):
      ```toml
      # treesitter-ls configuration
      # Documentation: https://github.com/atusy/treesitter-ls/blob/main/docs/README.md

      # Auto-install missing parsers and queries (default: true)
      # autoInstall = true

      # Custom search paths for parsers and queries
      # Default: ~/.local/share/treesitter-ls (Linux), ~/Library/Application Support/treesitter-ls (macOS)
      # searchPaths = ["/custom/path"]

      # Language-specific configuration (usually not needed)
      # [languages.custom_lang]
      # filetypes = ["ext"]
      # library = "/path/to/parser.so"
      # highlight = [{ path = "./queries/highlights.scm" }]

      # Capture name remapping (Tree-sitter -> LSP semantic tokens)
      # [captureMappings._.highlights]
      # "variable.builtin" = "variable.defaultLibrary"
      ```

  # Priority 4: Status command for debugging (depends on PBI-026)
  - id: PBI-023
    status: ready
    story:
      role: "user troubleshooting treesitter-ls"
      capability: "see which languages are installed and their status"
      benefit: "I can diagnose issues without manually checking directories"
    acceptance_criteria:
      - criterion: "treesitter-ls language status shows installed languages"
        verification: |
          ./target/release/treesitter-ls language status | grep -E "lua|rust|python"
      - criterion: "Status shows parser path and whether queries exist"
        verification: |
          ./target/release/treesitter-ls language status --verbose | grep -E "parser|queries"
      - criterion: "Status indicates languages with missing queries"
        verification: |
          # Create parser-only entry and verify status shows missing queries
          mkdir -p /tmp/test-status/parser
          touch /tmp/test-status/parser/test.dylib
          ./target/release/treesitter-ls language status --data-dir /tmp/test-status | grep -E "missing|incomplete"
    story_points: 2
    technical_notes: |
      CLI: treesitter-ls language status [--verbose] [--data-dir PATH]

      Output format:
      ```
      Installed languages (data dir: ~/.local/share/treesitter-ls):
        lua       ✓ parser  ✓ queries
        rust      ✓ parser  ✓ queries
        markdown  ✓ parser  ✗ queries (missing)
      ```

      Implementation:
      1. Add Language subcommand with Status action
      2. Scan parser/ directory for .so/.dylib files
      3. For each parser, check if queries/{lang}/highlights.scm exists
      4. Display formatted output

  # Priority 5: Uninstall command (depends on PBI-026)
  - id: PBI-024
    status: ready
    story:
      role: "user of treesitter-ls"
      capability: "remove installed parsers and queries"
      benefit: "I can clean up disk space or fix corrupted installations"
    acceptance_criteria:
      - criterion: "treesitter-ls language uninstall <language> removes parser and queries"
        verification: |
          ./target/release/treesitter-ls language install lua --data-dir /tmp/test-uninstall
          ./target/release/treesitter-ls language uninstall lua --data-dir /tmp/test-uninstall
          ! test -f /tmp/test-uninstall/parser/lua.dylib
          ! test -d /tmp/test-uninstall/queries/lua
      - criterion: "Uninstall confirms before deletion (unless --force)"
        verification: |
          echo "n" | ./target/release/treesitter-ls language uninstall lua 2>&1 | grep -i "cancel"
      - criterion: "Uninstall --all removes all installed languages"
        verification: |
          ./target/release/treesitter-ls language uninstall --all --data-dir /tmp/test-uninstall --force
          test -z "$(ls /tmp/test-uninstall/parser/ 2>/dev/null)"
    story_points: 2
    technical_notes: |
      CLI: treesitter-ls language uninstall <LANGUAGE|--all> [--force] [--data-dir PATH]

      Implementation:
      1. Add Uninstall action to Language subcommand
      2. Find and remove parser file: parser/{lang}.{so,dylib,dll}
      3. Remove queries directory: queries/{lang}/
      4. Prompt for confirmation unless --force
      5. Handle --all flag to remove everything

  # ============================================================================
  # COMPLETED PBIs (kept for reference)
  # ============================================================================

  # Priority 1: Bug fix for parser installation
  - id: PBI-015
    status: done
    story:
      role: "user of treesitter-ls"
      capability: "install parsers at specific git revisions (tags or commit hashes)"
      benefit: "I can reliably install parsers using nvim-treesitter's pinned revisions"
    acceptance_criteria:
      - criterion: "Installing a parser with a tag revision (e.g., v0.25.0) succeeds"
        verification: |
          rm -rf /tmp/test-python
          ./target/release/treesitter-ls install python --data-dir /tmp/test-python --verbose
          test -f /tmp/test-python/parser/python.dylib || test -f /tmp/test-python/parser/python.so
      - criterion: "Installing a parser with a commit hash revision succeeds"
        verification: |
          rm -rf /tmp/test-lua
          ./target/release/treesitter-ls install lua --data-dir /tmp/test-lua --verbose
          test -f /tmp/test-lua/parser/lua.dylib || test -f /tmp/test-lua/parser/lua.so
      - criterion: "Verbose output shows which revision was checked out"
        verification: |
          ./target/release/treesitter-ls install lua --data-dir /tmp/test-verbose --verbose --force 2>&1 | grep -i "revision"
    story_points: 1
    technical_notes: |
      Bug: git checkout <tag> fails in shallow clone after git fetch --depth 1 origin <tag>
      Fix: Use "git checkout FETCH_HEAD" instead of "git checkout <revision>"
      File: src/install/parser.rs - clone_repo() function

  # Priority 2: Performance improvement
  - id: PBI-010
    status: done
    story:
      role: "user of treesitter-ls"
      capability: "have parsers.lua cached locally to avoid repeated HTTP requests"
      benefit: "I can run multiple install commands quickly without waiting for network requests"
    acceptance_criteria:
      - criterion: "Second install command in same session reuses cached parsers.lua"
        verification: "Time two consecutive installs - second should be faster"
      - criterion: "Cache expires after 1 hour (configurable)"
        verification: "Verify cache TTL behavior through code review/unit tests"
      - criterion: "Cache can be bypassed with --no-cache flag"
        verification: "./target/release/treesitter-ls install lua --no-cache 2>&1 | grep -i fetch"
      - criterion: "Cache is stored in data directory"
        verification: "test -f /tmp/cache-test/cache/parsers.lua"
    story_points: 3

  # Priority 3: Robustness improvement
  - id: PBI-016
    status: done
    story:
      role: "user of treesitter-ls"
      capability: "continue using the language server even when a parser crashes"
      benefit: "I don't lose all functionality just because one language parser has a bug"
    acceptance_criteria:
      - criterion: "Server remains running when a parser triggers an assertion failure"
      - criterion: "Failed parser is marked as unavailable and won't crash again"
      - criterion: "Error message is logged with sufficient detail for debugging"
      - criterion: "Other languages continue to work normally after one parser crashes"
      - criterion: "Crashed parser can be retried after reinstallation"
    story_points: 8
    technical_notes: |
      Solution: State file crash detection (simpler than subprocess isolation)
      - Before parsing: write language to "parsing_in_progress" state file
      - After success: remove state file
      - On restart: if state file exists, mark that parser as crashed
      - CLI command: treesitter-ls crash-recovery {list,clear}
      - Failed parsers are skipped until user clears via CLI after reinstall

  # Priority 4: Query inheritance support (blocks TypeScript, JavaScript, etc.)
  - id: PBI-020
    status: done
    story:
      role: "user of treesitter-ls"
      capability: "get syntax highlighting for languages that use inherited queries (TypeScript, JavaScript, etc.)"
      benefit: "I can use treesitter-ls with popular languages that rely on nvim-treesitter's query inheritance"
    acceptance_criteria:
      - criterion: "TypeScript files are highlighted correctly"
        verification: |
          nvim --clean -u scripts/minimal_init.lua -c 'e __ignored/example.ts' -c 'sleep 2' -c 'lua print(vim.inspect(vim.api.nvim_buf_get_extmarks(0, -1, 0, -1, {details=true})))' -c 'qa!'
          # Should show semantic token highlights for 'const' and 'x'
      - criterion: "JavaScript files are highlighted correctly"
        verification: |
          echo 'const y = 2;' > /tmp/test.js
          nvim --clean -u scripts/minimal_init.lua -c 'e /tmp/test.js' -c 'sleep 2' -c 'lua print(vim.inspect(vim.api.nvim_buf_get_extmarks(0, -1, 0, -1, {details=true})))' -c 'qa!'
      - criterion: "Inherited queries (ecma, jsx) are automatically downloaded when installing typescript"
        verification: |
          rm -rf /tmp/test-ts
          ./target/release/treesitter-ls install typescript --data-dir /tmp/test-ts --verbose
          test -f /tmp/test-ts/queries/ecma/highlights.scm && echo "ecma downloaded"
      - criterion: "; inherits: directive is resolved and queries are concatenated in correct order"
        verification: |
          cargo test test_resolve_query_inheritance
      - criterion: "Circular inheritance is detected and reported as error"
        verification: |
          cargo test test_circular_inheritance_detection
    story_points: 5
    technical_notes: |
      Problem: nvim-treesitter queries use "; inherits: <lang>" directive to share common patterns.
      Example: TypeScript's highlights.scm starts with "; inherits: ecma"

      Chosen approach: Runtime resolution in QueryLoader
      - Simpler than pre-processing at install time
      - Works with existing installed queries
      - Auto-installs inherited queries when needed

      Implementation files:
      - src/language/query_loader.rs: Add resolve_inheritance() function
      - src/install/queries.rs: Add install_with_dependencies() to download inherited queries

      Key functions to add:
      1. parse_inherits_directive(content: &str) -> Vec<String>
         - Parse "; inherits: lang1,lang2" from first line
         - Return list of parent languages

      2. resolve_query_with_inheritance(search_paths, lang, file) -> String
         - Load query file
         - Parse inherits directive
         - Recursively resolve parents (depth-first, parents first)
         - Track visited to detect cycles
         - Concatenate: parent1 + parent2 + ... + child (remove inherits line)

      3. install_queries_with_dependencies(lang, data_dir, force)
         - Download query for lang
         - Parse inherits directive
         - Recursively install parent queries (ecma, jsx, etc.)
         - Skip if already installed (unless force)

      Inheritance examples from nvim-treesitter:
      - typescript: inherits ecma
      - javascript: inherits ecma,jsx
      - tsx: inherits typescript,jsx
      - ecma: no inheritance (base)
      - jsx: no inheritance (base)

      Edge cases:
      - ecma/jsx are query-only (no parser) - must skip parser install
      - Multiple inheritance: javascript inherits both ecma AND jsx
      - Transitive: tsx -> typescript -> ecma AND tsx -> jsx

---
# ==============================================================================
# DEFINITION OF READY
# ==============================================================================

definition_of_ready:
  criteria:
    - "AI can complete this story without human input"
    - "User story has role, capability, and benefit"
    - "At least 3 acceptance criteria with verification commands"
    - "Dependencies are resolved or not blocking"

---
# ==============================================================================
# DEFINITION OF DONE
# ==============================================================================

definition_of_done:
  checks:
    - name: "All unit tests pass"
      run: "make test"
    - name: "Code quality checks pass"
      run: "make check"
    - name: "E2E tests pass"
      run: "make test_nvim"

---
# ==============================================================================
# CURRENT SPRINT
# ==============================================================================

current_sprint:
  number: 14
  pbi: PBI-025
  status: done
  goal: "Architecture Decision Records documentation"
  subtasks:
    - id: S14.1
      task: "Create docs/adr/ directory with ADR template"
      status: done
    - id: S14.2
      task: "Create ADR-0001: Hierarchical CLI Subcommands"
      status: done

---
# ==============================================================================
# COMPLETED SPRINTS (Summary Only)
# ==============================================================================
# For detailed subtasks and commits: git log -- scrum.yaml

completed_sprints:
  - sprint: 14
    pbi: PBI-025
    outcome: "ADR documentation with template and ADR-0001 (hierarchical CLI subcommands)"
  - sprint: 13
    pbi: PBI-020
    outcome: "Query inheritance support via parse_inherits_directive() and resolve_query_with_inheritance()"
  - sprint: 12
    pbi: PBI-016
    outcome: "Parser crash resilience via state file detection and CLI recovery"
  - sprint: 11
    pbi: PBI-010
    outcome: "Cache parsers.lua locally with 1-hour TTL and --no-cache flag"
  - sprint: 10
    pbi: PBI-015
    outcome: "Fixed git checkout for tag revisions using FETCH_HEAD"
  - sprint: 9
    pbi: [PBI-017, PBI-018, PBI-019]
    outcome: "Zero-Config MVP complete - default searchPaths, autoInstall=true by default"
  - sprint: 8
    pbi: PBI-013
    outcome: "Auto-install for injected languages on file open"
  - sprint: 7
    pbi: PBI-008
    outcome: "Auto-install infrastructure (silent background install)"
  - sprint: 6
    pbi: PBI-009
    outcome: "Combined install command (parser + queries)"
  - sprint: 5
    pbi: PBI-006
    outcome: "Parser compilation via tree-sitter CLI"
  - sprint: 4
    pbi: PBI-005
    outcome: "Query downloading from nvim-treesitter"
  - sprint: 3
    pbi: PBI-004
    outcome: "CLI infrastructure with clap"
  - sprint: 2
    pbi: PBI-002
    outcome: "Unified semantic token handlers; fixed PBI-003"
  - sprint: 1
    pbi: PBI-001
    outcome: "Semantic tokens for injected languages"

---
# ==============================================================================
# IMPEDIMENTS
# ==============================================================================

impediments:
  active: []
  # Format: {id, description, impact, severity, status}

---
# ==============================================================================
# AGENTS
# ==============================================================================

agents:
  roles:
    product_owner: "@scrum-team-product-owner"
    scrum_master: "@scrum-team-scrum-master"
    developer: "@scrum-team-developer"
  events:
    planning: "@scrum-event-sprint-planning"
    review: "@scrum-event-sprint-review"
    retrospective: "@scrum-event-sprint-retrospective"
    refinement: "@scrum-event-backlog-refinement"
