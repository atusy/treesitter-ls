# AI-Agentic Scrum Dashboard
# Single source of truth for all Scrum artifacts
# Git tracks when changes were made - no timestamps needed
# Order is priority - higher items have higher priority
# Historical details: git log -- scrum.yaml

---
# ==============================================================================
# RULES (Condensed)
# ==============================================================================

rules:
  core:
    - "Single Source of Truth: This dashboard is the only place for Scrum artifacts"
    - "Git as History: Do not add timestamps. Use git log for history"
    - "Order is Priority: Items higher in lists have higher priority"
    - "1 Sprint = 1 PBI: Each Sprint delivers exactly one PBI"

  definition_of_ready:
    summary: "Ready = AI can complete it without asking humans"
    flow: "draft -> refining -> ready"

  tdd_workflow:
    cycle: "pending -> red (commit) -> green (commit) -> refactoring (commit) -> completed"
    discipline: "ONE commit per TDD phase. Never mix behavioral and structural changes"

  agent_responsibilities:
    product_owner: "Product Backlog, Product Goal, Sprint acceptance"
    scrum_master: "Sprint config, Impediments, Retrospective, Metrics"
    developer: "Subtask status, Progress, Notes, Impediments"

---
# ==============================================================================
# QUICK STATUS
# ==============================================================================

quick_status:
  current_sprint:
    number: 25
    pbi: PBI-034
    status: done
    goal: "Initialize logging backend with env_logger"
  impediments: 0

---
# ==============================================================================
# PRODUCT GOAL
# ==============================================================================

product_goal:
  statement: "Enable zero-configuration usage of treesitter-ls: users can start the LSP server and get syntax highlighting for any supported language without manual setup."
  mvp_status: COMPLETE
  mvp_definition: |
    Minimum Viable Zero-Config Experience:
    1. User starts treesitter-ls with no initialization options
    2. User opens a .lua file (or any supported language)
    3. treesitter-ls automatically:
       a. Detects the language from file extension (via LSP languageId)
       b. Installs the parser and queries if missing (autoInstall: true by default)
       c. Uses default searchPaths (~/.local/share/treesitter-ls)
       d. Provides semantic highlighting
    4. Power users can still override with explicit configuration
  owner: "@scrum-team-product-owner"

---
# ==============================================================================
# PRODUCT BACKLOG (Active Items Only)
# ==============================================================================
# Completed PBIs: PBI-001 through PBI-010, PBI-013 through PBI-027
# Tidying PBIs: PBI-029 through PBI-033 (technical debt reduction)
# For details: git log -- scrum.yaml
#
product_backlog:
  # ============================================================================
  # ACTIVE PBIs
  # ============================================================================
  - id: PBI-028
    status: done
    story:
      role: "user of treesitter-ls"
      capability: "get syntax highlighting without specifying searchPaths in config"
      benefit: "I can use zero-config mode as intended without manually configuring paths"
    acceptance_criteria:
      - criterion: "default_search_paths() returns base directory, not subdirectories"
        verification: |
          # Default should be ["/Users/.../treesitter-ls"], not [".../parser", ".../queries"]
          cargo test test_default_search_paths_format
      - criterion: "Highlighting works when searchPaths is not specified in init_options"
        verification: |
          # With searchPaths commented out in minimal_init.lua, opening a file should highlight
          nvim -es --headless -u scripts/minimal_init.lua -c "e tests/assets/example.lua" -c "sleep 2" -c "lua print(#vim.lsp.semantic_tokens.get(0, {}, {}) > 0 and 'OK' or 'FAIL')" -c "qa!"
      - criterion: "Documentation updated to clarify searchPaths format"
        verification: |
          grep -E "searchPaths.*base directory|searchPaths.*not.*subdirectories" docs/README.md
      - criterion: "Product goal MVP definition updated to reflect correct path format"
        verification: |
          grep -v "parser,queries" scrum.yaml | grep -E "default.*searchPaths"
    story_points: 2
    technical_notes: |
      Bug: default_search_paths() returns wrong path format

      Current behavior (BROKEN):
        default_search_paths() returns:
          [".../treesitter-ls/parser", ".../treesitter-ls/queries"]

        But resolve_library_path() expects base directories and appends "parser/" itself:
          PathBuf::from(path).join("parser").join(format!("{language}.so"))

        Result: Looks for ".../treesitter-ls/parser/parser/lua.so" → NOT FOUND

      Expected behavior:
        default_search_paths() should return:
          [".../treesitter-ls"]

        Then resolve_library_path() correctly finds:
          ".../treesitter-ls/parser/lua.so"

      Fix location: src/config.rs, default_search_paths() function

      Documentation to update:
        - docs/README.md: Clarify searchPaths format (base directories, not subdirs)
        - scrum.yaml: Fix product_goal.mvp_definition line 60

  # ============================================================================
  # TIDYING PBIs (Technical Debt Reduction)
  # ============================================================================
  - id: PBI-029
    status: done
    story:
      role: "developer maintaining treesitter-ls"
      capability: "work with a codebase free of dead and deprecated code"
      benefit: "I can understand the codebase faster without being confused by unused code"
    acceptance_criteria:
      - criterion: "No #[allow(dead_code)] annotations in production code"
        verification: |
          ! grep -r "#\[allow(dead_code)\]" src/ --include="*.rs" | grep -v test
      - criterion: "No #[deprecated] functions in the codebase"
        verification: |
          ! grep -r "#\[deprecated" src/ --include="*.rs"
      - criterion: "No placeholder tests with assert!(true)"
        verification: |
          ! grep -r "assert!(true)" src/ --include="*.rs"
      - criterion: "All tests pass after removal"
        verification: |
          cargo test
    story_points: 1
    technical_notes: |
      Quick Wins - Dead Code Removal (Tidy First candidates)

      1. src/lsp/lsp_impl.rs (lines 38-95):
         - Remove InstallingLanguages struct marked #[allow(dead_code)] at line 38
         - Remove impl block marked #[allow(dead_code)] at line 43
         - Remove is_parser_failed() marked #[allow(dead_code)] at line 180
         - Remove clear_failed_parser() marked #[allow(dead_code)] at line 187
         - These were for "later subtasks (ST-5)" that never materialized

      2. src/language/injection.rs:49-62:
         - Remove parse_offset_directive() marked #[deprecated]
         - Note says "returns incorrect offsets" - kept for testing only
         - Update test_parse_offset_directive_pattern_aware() to not use deprecated fn

      3. src/language/predicate_accessor.rs:78-91:
         - Remove or implement placeholder tests: test_predicate_accessor_basic()
           and test_unified_predicate_operator()
         - Currently just assert!(true)

      Estimated time: 15-20 minutes total

  - id: PBI-030
    status: done
    story:
      role: "developer maintaining treesitter-ls"
      capability: "use consistent lock handling patterns across the codebase"
      benefit: "I can trust that all locks are handled safely and code is DRY"
    acceptance_criteria:
      - criterion: "All lock() calls use LockResultExt trait methods"
        verification: |
          # No manual match on lock() result - use recover_poison_with_log() instead
          ! grep -A5 "\.lock()" src/lsp/lsp_impl.rs | grep "Err(poisoned)"
      - criterion: "LockResultExt is imported where locks are used"
        verification: |
          grep "use crate::error::LockResultExt" src/lsp/lsp_impl.rs
      - criterion: "All tests pass after refactoring"
        verification: |
          cargo test
      - criterion: "Clippy passes with no warnings"
        verification: |
          cargo clippy -- -D warnings
    story_points: 1
    technical_notes: |
      Eliminate Lock Pattern Duplication (Tidy First)

      Current state: 8+ instances of manual poison recovery in lsp_impl.rs:
        - Lines 53-62: InstallingLanguages::is_installing()
        - Lines 68-77: InstallingLanguages::try_start_install()
        - Lines 82-93: InstallingLanguages::finish_install()
        - Lines 236-244: parse_document() parser_pool lock
        - Lines 925-931: semantic tokens parser_pool lock
        - Lines 1036-1042: code actions parser_pool lock
        - Lines 1137-1143: selection range parser_pool lock
        - Lines 1223-1229: goto definition parser_pool lock

      The LockResultExt trait in error.rs already provides:
        - recover_poison() - silent recovery (returns Result)
        - recover_poison_with_log(context) - logged recovery (returns Result)

      Note: Both methods return Result<T, LspError>, so callers need to handle
      the Result (use .unwrap() or ? operator as appropriate).

      Refactor pattern:
        let pool = self.parser_pool.lock()
            .recover_poison_with_log("parse_document parser_pool")?;

      Estimated time: 20-30 minutes

  - id: PBI-031
    status: done
    story:
      role: "developer maintaining treesitter-ls"
      capability: "read dense functions with clear visual grouping"
      benefit: "I can quickly understand function flow by scanning logical chunks"
    acceptance_criteria:
      - criterion: "parse_document() has blank lines separating logical steps"
        verification: |
          # Manual review: lsp_impl.rs parse_document should have 4-5 logical chunks
          grep -A100 "fn parse_document" src/lsp/lsp_impl.rs | head -120
      - criterion: "handle_semantic_tokens_full() has blank lines separating phases"
        verification: |
          # Manual review: semantic.rs should chunk: setup, query, process, cache
          grep -A120 "fn handle_semantic_tokens_full" src/analysis/semantic.rs | head -140
      - criterion: "All tests pass (no behavioral change)"
        verification: |
          cargo test
      - criterion: "Code format check passes"
        verification: |
          cargo fmt --check
    story_points: 1
    technical_notes: |
      Chunk Statements in Dense Functions (Tidy First)

      Add blank lines to group related statements in:

      1. src/lsp/lsp_impl.rs - parse_document() (lines 201-290):
         - Chunk: Determine language from path or language_id
         - Chunk: Check if parser previously crashed
         - Chunk: Ensure language is loaded
         - Chunk: Acquire parser from pool and parse
         - Chunk: Store the parsed document

      2. src/analysis/semantic.rs - handle_semantic_tokens_full():
         - Chunk: Setup and early returns
         - Chunk: Query execution
         - Chunk: Token processing
         - Chunk: Caching and return

      Structural change only - no behavioral modifications.
      Estimated time: 10 minutes per function

  - id: PBI-032
    status: ready
    story:
      role: "developer maintaining treesitter-ls"
      capability: "work with a smaller, more focused lsp_impl.rs"
      benefit: "I can navigate and modify LSP code without scrolling through 2400 lines"
    acceptance_criteria:
      - criterion: "lsp_impl.rs is under 1500 lines"
        verification: |
          [ $(wc -l < src/lsp/lsp_impl.rs) -lt 1500 ]
      - criterion: "Auto-install logic extracted to separate module"
        verification: |
          test -f src/lsp/auto_install.rs
      - criterion: "Settings loading extracted to settings module"
        verification: |
          grep -q "fn load_settings" src/lsp/settings.rs
      - criterion: "All tests pass"
        verification: |
          cargo test
      - criterion: "Clippy passes"
        verification: |
          cargo clippy -- -D warnings
    story_points: 3
    technical_notes: |
      Split God Object: lsp_impl.rs (Tidy Later - Substantial)

      Current: 2391 lines handling multiple concerns

      Extraction targets:
      1. Auto-install logic → src/lsp/auto_install.rs (~200 lines)
         - maybe_auto_install_language() (lines 349-421)
         - reload_language_after_install() (lines 423-477)
         - check_injected_languages_auto_install() (lines 539-549+)
         - get_injected_languages() (lines 493-527)

      2. Settings loading → src/lsp/settings.rs (expand existing)
         - apply_settings() currently at line 303-308
         - Move settings-related helpers

      3. Document parsing → src/lsp/parsing.rs (~150 lines)
         - parse_document() (lines 201-290)
         - get_language_for_document() (lines 292-301)

      Keep in lsp_impl.rs:
      - LSP trait implementations (LanguageServer)
      - Request/notification routing
      - State coordination (TreeSitterLs struct)

      Estimated time: 2-3 hours

  - id: PBI-033
    status: ready
    story:
      role: "developer maintaining treesitter-ls"
      capability: "understand code action APIs without navigating multiple function variants"
      benefit: "I can extend code actions without confusion about which function to call"
    acceptance_criteria:
      - criterion: "Single entry point for code actions with options struct"
        verification: |
          grep -q "pub struct CodeActionOptions" src/analysis/refactor.rs
      - criterion: "No more than 2 public handle_code_actions functions"
        verification: |
          [ $(grep -c "pub fn handle_code_actions" src/analysis/refactor.rs) -le 2 ]
      - criterion: "All tests pass"
        verification: |
          cargo test
      - criterion: "Clippy passes"
        verification: |
          cargo clippy -- -D warnings
    story_points: 2
    technical_notes: |
      Consolidate Code Action Function Variants (Tidy Later)

      Current state (3 public + 2 private):
        Public:
        - handle_code_actions(...) at line 558
        - handle_code_actions_with_injection_query(...) at line 578
        - handle_code_actions_with_injection_and_coordinator(...) at line 602

        Private:
        - handle_code_actions_with_context(...) at line 627
        - handle_nested_injection(...) at line 395

      The CodeActionContext struct already exists internally (used by
      handle_code_actions_with_context). Refactor to expose it:

        pub struct CodeActionOptions<'a> {
            uri: &'a Url,
            text: &'a str,
            tree: &'a Tree,
            cursor: Range,
            queries: Option<(&'a Query, Option<&'a Query>)>,
            capture_context: Option<(&'a str, &'a CaptureMappings)>,
            injection_query: Option<&'a Query>,
            coordinator: Option<&'a LanguageCoordinator>,
            parser_pool: Option<&'a mut DocumentParserPool>,
        }

        impl<'a> CodeActionOptions<'a> {
            pub fn new(uri: &'a Url, text: &'a str, tree: &'a Tree, cursor: Range) -> Self
            pub fn with_injection(self, query: &'a Query) -> Self
            pub fn with_coordinator(self, coord: &'a LanguageCoordinator, pool: &'a mut DocumentParserPool) -> Self
        }

        pub fn handle_code_actions(options: CodeActionOptions) -> Option<Vec<CodeActionOrCommand>>

      Estimated time: 30-45 minutes

  # ============================================================================
  # LOGGING PBIs (Observability Improvements)
  # ============================================================================
  - id: PBI-034
    status: done
    story:
      role: "operator running treesitter-ls"
      capability: "see log messages via RUST_LOG environment variable"
      benefit: "I can diagnose issues when the LSP server misbehaves"
    acceptance_criteria:
      - criterion: "env_logger crate is added to Cargo.toml dependencies"
        verification: |
          grep -q 'env_logger' Cargo.toml
      - criterion: "env_logger::init() is called in run_lsp_server() before server starts"
        verification: |
          grep -q 'env_logger' src/bin/main.rs
      - criterion: "Log output goes to stderr (not stdout, which is used for LSP JSON-RPC)"
        verification: |
          grep -q 'Target::Stderr' src/bin/main.rs
      - criterion: "All tests pass"
        verification: |
          cargo test
    story_points: 2
    technical_notes: |
      Initialize Logging Backend (Foundation)

      The log crate is used throughout (line 18 in Cargo.toml) but no backend
      is initialized - all logs are no-ops.

      Implementation steps:
      1. Add to Cargo.toml dependencies:
         env_logger = "0.11"

      2. In src/bin/main.rs run_lsp_server() (line 505-516), add before server starts:
         use env_logger::Builder;

         Builder::from_default_env()
             .target(env_logger::Target::Stderr)  # CRITICAL: stdout is LSP JSON-RPC
             .init();

      MUST use stderr because stdout is the LSP protocol channel (JSON-RPC).

  - id: PBI-035
    status: ready
    story:
      role: "operator filtering logs"
      capability: "filter warnings by category using RUST_LOG targets"
      benefit: "I can see only relevant logs without noise from other categories"
    acceptance_criteria:
      - criterion: "src/error.rs:61 recover_poison() includes target: treesitter_ls::lock_recovery"
        verification: |
          grep -A5 'fn recover_poison\b' src/error.rs | grep 'target.*lock_recovery'
      - criterion: "src/language/injection.rs warnings use target: treesitter_ls::query"
        verification: |
          grep 'log::warn!' src/language/injection.rs | grep -c 'target.*treesitter_ls::query' | grep -q '2'
      - criterion: "All log::warn! calls have explicit targets"
        verification: |
          ! grep -r 'log::warn!' src/ --include='*.rs' | grep -v 'target:'
      - criterion: "All tests pass"
        verification: |
          cargo test
    story_points: 1
    dependencies:
      - "PBI-034 (logging backend must be initialized for targets to work)"
    technical_notes: |
      Standardize Log Targets

      Three log targets for different audiences:
        - treesitter_ls::lock_recovery  → Server operators (thread safety)
        - treesitter_ls::crash_recovery → Server operators (parser crashes)
        - treesitter_ls::query          → Query authors (malformed queries)

      Files to update:
        - src/error.rs:61 → add target: "treesitter_ls::lock_recovery"
          Current: log::warn!("Recovered from poisoned lock");
          Change:  log::warn!(target: "treesitter_ls::lock_recovery", "Recovered from poisoned lock");

        - src/language/injection.rs:88 → add target: "treesitter_ls::query"
          (Malformed #offset! directive - wrong argument count)

        - src/language/injection.rs:138 → add target: "treesitter_ls::query"
          (Failed to parse #offset! directive - invalid values)

      The injection.rs warnings are about malformed #offset! directives - user config
      issues, not server health. Separating them lets query authors filter independently.

  - id: PBI-036
    status: ready
    story:
      role: "developer debugging lock issues"
      capability: "see which operation triggered lock poisoning recovery"
      benefit: "I can identify which component experienced the lock poisoning"
    acceptance_criteria:
      - criterion: "recover_poison() function includes context in message"
        verification: |
          grep -A10 'fn recover_poison\b' src/error.rs | grep 'Recovered.*in'
      - criterion: "No context-less recover_poison variant exists"
        verification: |
          ! grep -A5 'fn recover_poison\b' src/error.rs | grep -q '"Recovered from poisoned lock"$'
      - criterion: "All callers of recover_poison provide context"
        verification: |
          ! grep -r 'recover_poison()' src/ --include='*.rs'
      - criterion: "All tests pass"
        verification: |
          cargo test
    story_points: 2
    dependencies:
      - "PBI-035 (targets should be standardized before consolidating)"
    technical_notes: |
      Add Context to Recover Poison Warning

      Current state in error.rs:
        - recover_poison() at line 57-64: no target, no context
          log::warn!("Recovered from poisoned lock");
        - recover_poison_with_log() at line 67-79: has target and context
          log::warn!(target: "treesitter_ls::lock_recovery", "Recovered from poisoned lock in {}", context);

      Recommended approach (Option 3):
        1. Remove recover_poison() (the context-less variant)
        2. Rename recover_poison_with_log(context) to recover_poison(context)
        3. Update all callers to use the new signature

      This ensures ALL lock recovery is logged with context for debugging.
      After PBI-030, most callers will already use recover_poison_with_log().

  - id: PBI-037
    status: ready
    story:
      role: "operator monitoring logs"
      capability: "see crash detection events at error level instead of warn"
      benefit: "I can configure alerts on the more severe error level for crashes"
    acceptance_criteria:
      - criterion: "src/language/failed_parsers.rs uses log::error! for crash detection"
        verification: |
          grep 'log::error!' src/language/failed_parsers.rs | grep 'crash_recovery'
      - criterion: "Target remains treesitter_ls::crash_recovery"
        verification: |
          grep 'crash_recovery' src/language/failed_parsers.rs
      - criterion: "All tests pass"
        verification: |
          cargo test
    story_points: 1
    dependencies:
      - "PBI-034 (logging backend must be initialized)"
    technical_notes: |
      Use Error Level for Crash Detection

      Crash detection indicates a parser caused SIGABRT - genuinely an error condition.
      The warn level is for "recovered gracefully"; crash means "something bad happened".

      Change in src/language/failed_parsers.rs:68-72:
        Current:
          log::warn!(
              target: "treesitter_ls::crash_recovery",
              "Detected crash during parsing of '{}'. Marking as failed.",
              language
          );

        Change to:
          log::error!(
              target: "treesitter_ls::crash_recovery",
              "Detected crash during parsing of '{}'. Marking as failed.",
              language
          );

      This is a one-line change (warn! -> error!) with clear semantic meaning.

  - id: PBI-038
    status: ready
    story:
      role: "operator configuring treesitter-ls"
      capability: "read documentation about available log targets"
      benefit: "I can configure RUST_LOG effectively without reading source code"
    acceptance_criteria:
      - criterion: "docs/README.md includes Logging section"
        verification: |
          grep -q '## Logging' docs/README.md
      - criterion: "Documents all three log targets with descriptions"
        verification: |
          grep -q 'lock_recovery' docs/README.md && grep -q 'crash_recovery' docs/README.md && grep -q 'treesitter_ls::query' docs/README.md
      - criterion: "Includes example RUST_LOG configurations"
        verification: |
          grep -q 'RUST_LOG=' docs/README.md
      - criterion: "Notes that logs go to stderr"
        verification: |
          grep -qi 'stderr' docs/README.md
    story_points: 2
    dependencies:
      - "PBI-034 (logging backend must exist to document)"
      - "PBI-035 (log targets must be standardized to document)"
      - "PBI-037 (crash_recovery level must be finalized)"
    technical_notes: |
      Document Logging Targets

      Add new section to docs/README.md (after Troubleshooting section):

      ## Logging

      treesitter-ls uses Rust's standard logging with env_logger.
      Enable logging via RUST_LOG environment variable.

      ### Log Targets

      | Target | Level | Description |
      |--------|-------|-------------|
      | treesitter_ls::lock_recovery | warn | Thread synchronization recovery events |
      | treesitter_ls::crash_recovery | error | Parser crash detection and recovery |
      | treesitter_ls::query | warn | Query syntax/validation issues |

      ### Examples

      ```bash
      # All logs at debug level
      RUST_LOG=treesitter_ls=debug treesitter-ls

      # Only crash events
      RUST_LOG=treesitter_ls::crash_recovery=error treesitter-ls

      # Query issues (helpful for query authors)
      RUST_LOG=treesitter_ls::query=warn treesitter-ls
      ```

      **Note:** Logs are written to stderr. Stdout is reserved for LSP JSON-RPC protocol.

  # ============================================================================
  # COMPLETED PBIs (details in git history)
  # ============================================================================
  - id: PBI-025
    status: done
  - id: PBI-026
    status: done
  - id: PBI-021
    status: done
  - id: PBI-022
    status: done
  - id: PBI-023
    status: done
  - id: PBI-024
    status: done
  - id: PBI-027
    status: done
  - id: PBI-015
    status: done
  - id: PBI-010
    status: done
  - id: PBI-016
    status: done
  - id: PBI-020
    status: done

---
# ==============================================================================
# DEFINITION OF READY
# ==============================================================================

definition_of_ready:
  criteria:
    - "AI can complete this story without human input"
    - "User story has role, capability, and benefit"
    - "At least 3 acceptance criteria with verification commands"
    - "Dependencies are resolved or not blocking"

---
# ==============================================================================
# DEFINITION OF DONE
# ==============================================================================

definition_of_done:
  checks:
    - name: "All unit tests pass"
      run: "make test"
    - name: "Code quality checks pass"
      run: "make check"
    - name: "E2E tests pass"
      run: "make test_nvim"

---
# ==============================================================================
# CURRENT SPRINT
# ==============================================================================

current_sprint:
  number: 25
  pbi: PBI-034
  status: done
  goal: "Initialize logging backend with env_logger"
  subtasks:
    - id: S25.1
      task: "Add env_logger crate to Cargo.toml"
      status: completed
    - id: S25.2
      task: "Initialize env_logger in run_lsp_server() with stderr target"
      status: completed

---
# ==============================================================================
# COMPLETED SPRINTS (Summary Only)
# ==============================================================================
# For detailed subtasks and commits: git log -- scrum.yaml

completed_sprints:
  - sprint: 25
    pbi: PBI-034
    outcome: "Initialized logging backend with env_logger, enabling RUST_LOG configuration"
  - sprint: 24
    pbi: PBI-031
    outcome: "Added phase markers in handle_semantic_tokens_full for better readability"
  - sprint: 23
    pbi: PBI-030
    outcome: "Standardized lock handling with LockResultExt trait, reduced duplication"
  - sprint: 22
    pbi: PBI-029
    outcome: "Removed dead code: deprecated functions, placeholder tests, stale annotations"
  - sprint: 21
    pbi: PBI-028
    outcome: "Fixed default_search_paths() to return base directory, enabling zero-config mode"
  - sprint: 20
    pbi: PBI-027
    outcome: "Fixed markdown selection range test expectation to match AST structure"
  - sprint: 19
    pbi: PBI-024
    outcome: "Added language uninstall command with confirmation prompt and --all flag"
  - sprint: 18
    pbi: PBI-023
    outcome: "Added language status command to show installed languages and missing components"
  - sprint: 17
    pbi: PBI-022
    outcome: "Added config init command to generate treesitter-ls.toml template"
  - sprint: 16
    pbi: PBI-021
    outcome: "Added Prerequisites section to docs/README.md with dependency requirements"
  - sprint: 15
    pbi: PBI-026
    outcome: "CLI migrated to hierarchical structure: treesitter-ls language {install,list}"
  - sprint: 14
    pbi: PBI-025
    outcome: "ADR documentation with template and ADR-0001 (hierarchical CLI subcommands)"
  - sprint: 13
    pbi: PBI-020
    outcome: "Query inheritance support via parse_inherits_directive() and resolve_query_with_inheritance()"
  - sprint: 12
    pbi: PBI-016
    outcome: "Parser crash resilience via state file detection and CLI recovery"
  - sprint: 11
    pbi: PBI-010
    outcome: "Cache parsers.lua locally with 1-hour TTL and --no-cache flag"
  - sprint: 10
    pbi: PBI-015
    outcome: "Fixed git checkout for tag revisions using FETCH_HEAD"
  - sprint: 9
    pbi: [PBI-017, PBI-018, PBI-019]
    outcome: "Zero-Config MVP complete - default searchPaths, autoInstall=true by default"
  - sprint: 8
    pbi: PBI-013
    outcome: "Auto-install for injected languages on file open"
  - sprint: 7
    pbi: PBI-008
    outcome: "Auto-install infrastructure (silent background install)"
  - sprint: 6
    pbi: PBI-009
    outcome: "Combined install command (parser + queries)"
  - sprint: 5
    pbi: PBI-006
    outcome: "Parser compilation via tree-sitter CLI"
  - sprint: 4
    pbi: PBI-005
    outcome: "Query downloading from nvim-treesitter"
  - sprint: 3
    pbi: PBI-004
    outcome: "CLI infrastructure with clap"
  - sprint: 2
    pbi: PBI-002
    outcome: "Unified semantic token handlers; fixed PBI-003"
  - sprint: 1
    pbi: PBI-001
    outcome: "Semantic tokens for injected languages"

---
# ==============================================================================
# IMPEDIMENTS
# ==============================================================================

impediments:
  active: []
  # Format: {id, description, impact, severity, status}

---
# ==============================================================================
# AGENTS
# ==============================================================================

agents:
  roles:
    product_owner: "@scrum-team-product-owner"
    scrum_master: "@scrum-team-scrum-master"
    developer: "@scrum-team-developer"
  events:
    planning: "@scrum-event-sprint-planning"
    review: "@scrum-event-sprint-review"
    retrospective: "@scrum-event-sprint-retrospective"
    refinement: "@scrum-event-backlog-refinement"
